<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Fuel Rust SDK</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">The Fuel Rust SDK</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/setup.html"><strong aria-hidden="true">1.1.</strong> Setup and Run</a></li><li class="chapter-item expanded "><a href="getting-started/terminology.html"><strong aria-hidden="true">1.2.</strong> Terminology</a></li></ol></li><li class="chapter-item expanded "><a href="getting-started/connecting.html"><strong aria-hidden="true">2.</strong> Connecting to a Fuel node</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="providers/external-node.html"><strong aria-hidden="true">2.1.</strong> Connecting to the Testnet or an external node</a></li><li class="chapter-item expanded "><a href="providers/short-lived.html"><strong aria-hidden="true">2.2.</strong> Running a short-lived Fuel node with the SDK</a></li><li class="chapter-item expanded "><a href="providers/querying.html"><strong aria-hidden="true">2.3.</strong> Querying the blockchain</a></li></ol></li><li class="chapter-item expanded "><a href="getting-started/account.html"><strong aria-hidden="true">3.</strong> Accounts</a></li><li class="chapter-item expanded "><a href="getting-started/managing-wallets.html"><strong aria-hidden="true">4.</strong> Managing wallets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="wallets/private-keys.html"><strong aria-hidden="true">4.1.</strong> Creating a wallet from a private key</a></li><li class="chapter-item expanded "><a href="wallets/mnemonic-wallet.html"><strong aria-hidden="true">4.2.</strong> Creating a wallet from mnemonic phrases</a></li><li class="chapter-item expanded "><a href="wallets/access.html"><strong aria-hidden="true">4.3.</strong> Wallet Access</a></li><li class="chapter-item expanded "><a href="wallets/encrypting-and-storing.html"><strong aria-hidden="true">4.4.</strong> Encrypting and storing wallets</a></li><li class="chapter-item expanded "><a href="wallets/checking-balances-and-coins.html"><strong aria-hidden="true">4.5.</strong> Checking balances and coins</a></li><li class="chapter-item expanded "><a href="wallets/test-wallets.html"><strong aria-hidden="true">4.6.</strong> Setting up test wallets</a></li><li class="chapter-item expanded "><a href="wallets/signing.html"><strong aria-hidden="true">4.7.</strong> Signing</a></li></ol></li><li class="chapter-item expanded "><a href="getting-started/abigen.html"><strong aria-hidden="true">5.</strong> Generating bindings with abigen!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="abigen/the-json-abi-file.html"><strong aria-hidden="true">5.1.</strong> The JSON ABI file</a></li><li class="chapter-item expanded "><a href="abigen/the-abigen-macro.html"><strong aria-hidden="true">5.2.</strong> The abigen! macro</a></li></ol></li><li class="chapter-item expanded "><a href="getting-started/contracts.html"><strong aria-hidden="true">6.</strong> Deploying contracts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contracts/configurable-constants.html"><strong aria-hidden="true">6.1.</strong> Configurable constants</a></li><li class="chapter-item expanded "><a href="contracts/interacting-with-contracts.html"><strong aria-hidden="true">6.2.</strong> Interacting with contracts</a></li><li class="chapter-item expanded "><a href="contracts/the-fuelvm-binary-file.html"><strong aria-hidden="true">6.3.</strong> The FuelVM Binary file</a></li></ol></li><li class="chapter-item expanded "><a href="getting-started/calling-contracts.html"><strong aria-hidden="true">7.</strong> Calling contracts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="calling-contracts/calls-with-different-wallets.html"><strong aria-hidden="true">7.1.</strong> Connecting wallets</a></li><li class="chapter-item expanded "><a href="calling-contracts/tx-params.html"><strong aria-hidden="true">7.2.</strong> Transaction parameters</a></li><li class="chapter-item expanded "><a href="calling-contracts/call-params.html"><strong aria-hidden="true">7.3.</strong> Call parameters</a></li><li class="chapter-item expanded "><a href="calling-contracts/custom-asset-transfer.html"><strong aria-hidden="true">7.4.</strong> Custom asset transfer</a></li><li class="chapter-item expanded "><a href="calling-contracts/call-response.html"><strong aria-hidden="true">7.5.</strong> Call response</a></li><li class="chapter-item expanded "><a href="calling-contracts/logs.html"><strong aria-hidden="true">7.6.</strong> Logs</a></li><li class="chapter-item expanded "><a href="calling-contracts/variable-outputs.html"><strong aria-hidden="true">7.7.</strong> Variable outputs and messages</a></li><li class="chapter-item expanded "><a href="calling-contracts/read-only.html"><strong aria-hidden="true">7.8.</strong> Read-only calls</a></li><li class="chapter-item expanded "><a href="calling-contracts/other-contracts.html"><strong aria-hidden="true">7.9.</strong> Calling other contracts</a></li><li class="chapter-item expanded "><a href="calling-contracts/multicalls.html"><strong aria-hidden="true">7.10.</strong> Multiple contract calls</a></li><li class="chapter-item expanded "><a href="calling-contracts/tx-dependency-estimation.html"><strong aria-hidden="true">7.11.</strong> Transaction dependency estimation</a></li><li class="chapter-item expanded "><a href="calling-contracts/cost-estimation.html"><strong aria-hidden="true">7.12.</strong> Estimating cost</a></li></ol></li><li class="chapter-item expanded "><a href="getting-started/running-scripts.html"><strong aria-hidden="true">8.</strong> Running scripts</a></li><li class="chapter-item expanded "><a href="getting-started/predicates.html"><strong aria-hidden="true">9.</strong> Predicates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="predicates/send-spend-predicate.html"><strong aria-hidden="true">9.1.</strong> Signatures example</a></li></ol></li><li class="chapter-item expanded "><a href="types/index.html"><strong aria-hidden="true">10.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/bytes32.html"><strong aria-hidden="true">10.1.</strong> Bytes32</a></li><li class="chapter-item expanded "><a href="types/address.html"><strong aria-hidden="true">10.2.</strong> Address</a></li><li class="chapter-item expanded "><a href="types/contract-id.html"><strong aria-hidden="true">10.3.</strong> ContractId</a></li><li class="chapter-item expanded "><a href="types/asset-id.html"><strong aria-hidden="true">10.4.</strong> AssetId</a></li><li class="chapter-item expanded "><a href="types/conversion.html"><strong aria-hidden="true">10.5.</strong> Converting native types</a></li><li class="chapter-item expanded "><a href="types/bech32.html"><strong aria-hidden="true">10.6.</strong> Bech32</a></li><li class="chapter-item expanded "><a href="types/custom_types.html"><strong aria-hidden="true">10.7.</strong> Structs and enums</a></li><li class="chapter-item expanded "><a href="types/string.html"><strong aria-hidden="true">10.8.</strong> String</a></li><li class="chapter-item expanded "><a href="types/bits256.html"><strong aria-hidden="true">10.9.</strong> Bits256</a></li><li class="chapter-item expanded "><a href="types/B512.html"><strong aria-hidden="true">10.10.</strong> B512</a></li><li class="chapter-item expanded "><a href="types/evm_address.html"><strong aria-hidden="true">10.11.</strong> EvmAddress</a></li><li class="chapter-item expanded "><a href="types/vectors.html"><strong aria-hidden="true">10.12.</strong> Vectors</a></li></ol></li><li class="chapter-item expanded "><a href="getting-started/api.html"><strong aria-hidden="true">11.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="testing/index.html"><strong aria-hidden="true">12.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/basics.html"><strong aria-hidden="true">12.1.</strong> Testing basics</a></li><li class="chapter-item expanded "><a href="testing/the-setup-contract-test-macro.html"><strong aria-hidden="true">12.2.</strong> The setup_contract_test! macro</a></li><li class="chapter-item expanded "><a href="testing/chains.html"><strong aria-hidden="true">12.3.</strong> Tweaking the blockchain</a></li></ol></li><li class="chapter-item expanded "><a href="cookbook/cookbook.html"><strong aria-hidden="true">13.</strong> Cookbook</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cookbook/custom-chain.html"><strong aria-hidden="true">13.1.</strong> Custom consensus parameters</a></li><li class="chapter-item expanded "><a href="cookbook/deposit-and-withdraw.html"><strong aria-hidden="true">13.2.</strong> Deposit and Withdraw</a></li><li class="chapter-item expanded "><a href="cookbook/transfer-all-assets.html"><strong aria-hidden="true">13.3.</strong> Transfer all assets</a></li></ol></li><li class="chapter-item expanded "><a href="debugging/debugging.html"><strong aria-hidden="true">14.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="debugging/function-selector.html"><strong aria-hidden="true">14.1.</strong> The Function selector</a></li></ol></li><li class="chapter-item expanded "><a href="contributing/contributing.html"><strong aria-hidden="true">15.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing/tests-structure.html"><strong aria-hidden="true">15.1.</strong> Integration tests structure</a></li></ol></li><li class="chapter-item expanded "><a href="cli/index.html"><strong aria-hidden="true">16.</strong> Command Line Interfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cli/fuels-abi-cli.html"><strong aria-hidden="true">16.1.</strong> fuels-abi-cli</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Fuel Rust SDK</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/FuelLabs/fuels-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-fuel-rust-sdk"><a class="header" href="#the-fuel-rust-sdk">The Fuel Rust SDK</a></h1>
<p>Rust SDK for Fuel. It can be used for a variety of things, including but not limited to:</p>
<ul>
<li>Compiling, deploying, and testing <a href="https://github.com/FuelLabs/sway">Sway</a> contracts;</li>
<li>Use the <a href="providers/external-node.html">Testnet</a> or run a local Fuel node;</li>
<li>Crafting and signing transactions with hand-crafted scripts or contract calls;</li>
<li>Generating type-safe Rust bindings of contract ABI methods;</li>
<li>And more. <code>fuels-rs</code> is still in active development.</li>
</ul>
<p>This book is an overview of the different things one can achieve using the Rust SDK, and how to implement them. Keep in mind that both the SDK and the documentation are works-in-progress!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This section gives some pointers for using the Fuel SDK for smart contract
development.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-and-running-the-fuel-rust-sdk"><a class="header" href="#setting-up-and-running-the-fuel-rust-sdk">Setting up and running the Fuel Rust SDK</a></h1>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<ul>
<li><a href="https://fuellabs.github.io/sway/master/introduction/installation.html">The latest <code>stable</code> Rust toolchain</a>;</li>
<li><a href="https://fuellabs.github.io/sway/master/introduction/installation.html#installing-from-cargo"><code>forc</code> and <code>fuel-core</code> binaries</a>.</li>
</ul>
<p><code>forc</code> is Sway equivalent of Rust's <code>cargo</code>. <code>fuel-core</code> is a Fuel full node implementation.</p>
<p>There are two main ways you can use the Fuel Rust SDK:</p>
<ol>
<li>Creating a new Sway project with <code>forc</code> and running the tests</li>
<li>Creating a standalone project and importing the <code>fuels-rs</code> crate</li>
</ol>
<h2 id="creating-a-new-project-with-forc"><a class="header" href="#creating-a-new-project-with-forc">Creating a new project with Forc</a></h2>
<p>You can create a new Sway project with</p>
<pre><code>forc new &lt;Project name&gt;
</code></pre>
<p>Or you can initialize a project within an existing folder with</p>
<pre><code>forc init
</code></pre>
<h3 id="adding-a-rust-integration-test-to-the-sway-project"><a class="header" href="#adding-a-rust-integration-test-to-the-sway-project">Adding a Rust integration test to the Sway project</a></h3>
<p>Now that we have a new project, we can add a Rust integration test using a <code>cargo generate</code> template.
If <code>cargo generate</code> is not already installed, you can instal it with:</p>
<pre><code>cargo install cargo-generate
</code></pre>
<blockquote>
<p><strong>Note</strong> You can learn more about cargo generate by visiting its <a href="https://github.com/cargo-generate/cargo-generate">repository</a>.</p>
</blockquote>
<p>Let's generate the default test harness with the following command:</p>
<pre><code>cargo generate --init fuellabs/sway templates/sway-test-rs --name &lt;Project name&gt; --force
</code></pre>
<p><code>--force</code> forces your <code>--name</code> input to retain your desired casing for the <code>{{project-name}}</code> placeholder in the template. Otherwise, <code>cargo-generate</code> automatically converts it to kebab-case. With <code>--force</code>, this means that both <code>my_fuel_project</code> and <code>my-fuel-project</code> are valid project names, depending on your needs.</p>
<p>Before running test, we need to build the Sway project with:</p>
<pre><code>forc build
</code></pre>
<p>Afterwards, we can run the test with:</p>
<pre><code>cargo test
</code></pre>
<blockquote>
<p><strong>Note</strong> If you need to capture output from the tests, use one of the following commands:</p>
</blockquote>
<pre><code>cargo test -- --nocapture
</code></pre>
<h2 id="importing-the-fuel-rust-sdk"><a class="header" href="#importing-the-fuel-rust-sdk">Importing the Fuel Rust SDK</a></h2>
<p>Add these dependencies on your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">fuels = &quot;0.40&quot;
</code></pre>
<blockquote>
<p><strong>Note</strong> We're using version <code>0.40</code> of the SDK, which is the latest version at the time of this writing.</p>
</blockquote>
<p>And then, in your Rust file that's going to make use of the SDK:</p>
<pre><code class="language-rust ignore">use fuels::prelude::*;
</code></pre>
<h2 id="the-fuel-rust-sdk-source-code"><a class="header" href="#the-fuel-rust-sdk-source-code">The Fuel Rust SDK source code</a></h2>
<p>Another way to experience the SDK is to look at the source code. The <code>packages/fuels/tests/</code> folder is full of integration tests that go through almost all aspects of the SDK.</p>
<blockquote>
<p><strong>Note</strong> Before running the tests, we need to build all the Sway test projects. The file <code>packages/fuels/Forc.toml</code> contains a `[workspace], which members are the paths to all integration tests.
To build these tests, run the following command:</p>
</blockquote>
<pre><code>forc build --path packages/fuels
</code></pre>
<blockquote>
<p><code>forc</code> can also be used to clean and format the test projects. Check the <code>help</code> output for more info.</p>
</blockquote>
<p>After building the projects, we can run the tests with</p>
<pre><code>cargo test
</code></pre>
<p>If you need all targets and all features, you can run</p>
<pre><code>cargo test --all-targets --all-features
</code></pre>
<blockquote>
<p><strong>Note</strong> If you need to capture output from the tests, you can run</p>
</blockquote>
<pre><code>cargo test -- --nocapture
</code></pre>
<h2 id="more-in-depth-fuel-and-sway-knowledge"><a class="header" href="#more-in-depth-fuel-and-sway-knowledge">More in-depth Fuel and Sway knowledge</a></h2>
<p>Read <a href="https://fuellabs.github.io/sway/master/introduction/sway_quickstart.html">The Sway Book</a> for more in-depth knowledge about Sway, the official smart contract language for the Fuel Virtual Machine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminology"><a class="header" href="#terminology">Terminology</a></h1>
<p>These are the common terms you will find across this documentation and while using the SDK.</p>
<h2 id="contract"><a class="header" href="#contract">Contract</a></h2>
<p>A contract, in the SDK, is an abstraction that represents a connection to a specific smart contract deployed on the Fuel Network. This contract instance can be used as a regular Rust object, with methods attached to it that reflect those in its smart contract equivalent.</p>
<h2 id="provider"><a class="header" href="#provider">Provider</a></h2>
<p>A Provider is a struct that provides an abstraction for a connection to a Fuel node. It provides read-only access to the node. You can use this provider as-is or through the wallet.</p>
<h2 id="wallet-and-signer"><a class="header" href="#wallet-and-signer">Wallet and signer</a></h2>
<p>A <code>Wallet</code> is a struct with direct or indirect access to a private key. You can use a <code>Wallet</code> to sign messages and transactions to authorize the network to charge your account to perform operations. The terms wallet and signer in the SDK are often used interchangeably, but, technically, a <code>Signer</code> is simply a Rust trait to enable the signing of transactions and messages; the <code>Wallet</code> implements the <code>Signer</code> trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connecting-to-a-fuel-node"><a class="header" href="#connecting-to-a-fuel-node">Connecting to a Fuel node</a></h1>
<p>At a high level, you can use the Fuel Rust SDK to build Rust-based applications that can run computations on the Fuel Virtual Machine through interactions with smart contracts written in Sway.</p>
<p>For this interaction to work, the SDK must be able to communicate with a <code>fuel-core</code> node; you have two options at your disposal:</p>
<ol>
<li>Use the <a href="getting-started/../providers/external-node.html">Testnet</a> or run a Fuel node (using <code>fuel-core</code>) and instantiate a provider that points to that node's IP and port.</li>
<li>Use the SDK's native <code>launch_provider_and_get_wallet()</code> that runs a short-lived test Fuel node;</li>
</ol>
<p>The second option is ideal for smart contract testing, as you can quickly spin up and tear down nodes between specific test cases.</p>
<p>For application building, you should use the first option.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connecting-to-the-testnet-or-an-external-node"><a class="header" href="#connecting-to-the-testnet-or-an-external-node">Connecting to the Testnet or an external node</a></h1>
<p>We can interact with the <code>Testnet</code> node by using the following example.</p>
<pre><code class="language-rust ignore">        use std::str::FromStr;

        use fuels::{accounts::fuel_crypto::SecretKey, prelude::*};

        // Create a provider pointing to the testnet.
        let provider = Provider::connect(&quot;node-beta-2.fuel.network&quot;).await.unwrap();

        // Setup a private key
        let secret =
            SecretKey::from_str(&quot;a1447cd75accc6b71a976fd3401a1f6ce318d27ba660b0315ee6ac347bf39568&quot;)
                .unwrap();

        // Create the wallet
        let wallet = WalletUnlocked::new_from_private_key(secret, Some(provider));

        // Get the wallet address. Used later with the faucet
        dbg!(wallet.address().to_string());
</code></pre>
<p>In the code example, we connected a new provider to the Testnet node and created a new wallet from a private key.</p>
<blockquote>
<p><strong>Note:</strong> New wallets on the Testnet will not have any assets! They can be obtained by providing the wallet address to the faucet at</p>
<p><a href="https://faucet-beta-2.fuel.network">faucet-beta-2.fuel.network</a></p>
<p>Once the assets have been transferred to the wallet, you can reuse it in other tests by providing the private key!</p>
<p>In addition to the faucet, there is a block explorer for the Tesnet at</p>
<p><a href="https://fuellabs.github.io/block-explorer-v2">block-explorer</a></p>
</blockquote>
<p>If you want to connect to another node just change the url or IP and port. For example, to connect to a local node that was created with <code>fuel-core</code> you can use:</p>
<pre><code class="language-rust ignore">        let _provider = Provider::connect(&quot;127.0.0.1:4000&quot;).await.unwrap();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-a-short-lived-fuel-node-with-the-sdk"><a class="header" href="#running-a-short-lived-fuel-node-with-the-sdk">Running a short-lived Fuel node with the SDK</a></h1>
<p>You can use the SDK to spin up a local, ideally short-lived Fuel node. Then, you can instantiate a Fuel client, pointing to this node.</p>
<pre><code class="language-rust ignore">        use fuels::{
            client::FuelClient,
            fuel_node::{Config, FuelService},
        };

        // Run the fuel node.
        let server = FuelService::new_node(Config::local_node())
            .await
            .map_err(|err| error!(InfrastructureError, &quot;{err}&quot;))?;

        // Create a client that will talk to the node created above.
        let client = FuelClient::from(server.bound_address);
        assert!(client.health().await?);
</code></pre>
<p>This approach is ideal for contract testing.</p>
<p>You can also use the test helper <code>setup_test_provider()</code> for this:</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;

        // Use the test helper to setup a test provider.
        let (provider, _address) = setup_test_provider(vec![], vec![], None, None).await;

        // Create the wallet.
        let _wallet = WalletUnlocked::new_random(Some(provider));
</code></pre>
<p>You can also use <code>launch_provider_and_get_wallet()</code>, which abstracts away the <code>setup_test_provider()</code> and the wallet creation, all in one single method:</p>
<pre><code class="language-rust ignore">let wallet = launch_provider_and_get_wallet().await;
</code></pre>
<h1 id="features"><a class="header" href="#features">Features</a></h1>
<h2 id="fuel-core-lib"><a class="header" href="#fuel-core-lib">Fuel-core lib</a></h2>
<p>The <code>fuel-core-lib</code> is a feature defined in the <code>fuels</code> library, allowing us to run a <code>fuel-core</code> node without installing the <code>fuel-core</code> binary on the local machine. Using the <code>fuel-core-lib</code> feature flag entails downloading all the dependencies needed to run the fuel-core node.</p>
<pre><code class="language-rust ignore">fuels = { version = &quot;0.40.0&quot;, features = [&quot;fuel-core-lib&quot;] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-the-blockchain"><a class="header" href="#interacting-with-the-blockchain">Interacting with the blockchain</a></h1>
<p>Once you set up a provider, you can interact with the Fuel blockchain. Here are a few examples of what you can do with a provider; for a more in-depth overview of the API, check the <a href="https://docs.rs/fuels/latest/fuels/accounts/provider/struct.Provider.html">official provider API documentation</a>.</p>
<ul>
<li><a href="providers/querying.html#interacting-with-the-blockchain">Interacting with the blockchain</a>
<ul>
<li><a href="providers/querying.html#set-up">Set up</a></li>
<li><a href="providers/querying.html#get-all-coins-from-an-address">Get all coins from an address</a></li>
<li><a href="providers/querying.html#get-spendable-resources-owned-by-an-address">Get spendable resources owned by an address</a></li>
<li><a href="providers/querying.html#get-balances-from-an-address">Get balances from an address</a></li>
</ul>
</li>
</ul>
<h2 id="set-up"><a class="header" href="#set-up">Set up</a></h2>
<p>You might need to set up a test blockchain first. You can skip this step if you're connecting to an external blockchain.</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;

        // Set up our test blockchain.

        // Create a random wallet (more on wallets later).
        let wallet = WalletUnlocked::new_random(None);

        // How many coins in our wallet.
        let number_of_coins = 1;

        // The amount/value in each coin in our wallet.
        let amount_per_coin = 3;

        let coins = setup_single_asset_coins(
            wallet.address(),
            BASE_ASSET_ID,
            number_of_coins,
            amount_per_coin,
        );

        let (provider, _) = setup_test_provider(coins.clone(), vec![], None, None).await;
</code></pre>
<h2 id="get-all-coins-from-an-address"><a class="header" href="#get-all-coins-from-an-address">Get all coins from an address</a></h2>
<p>This method returns all unspent coins (of a given asset ID) from a wallet.</p>
<pre><code class="language-rust ignore">        let coins = provider.get_coins(wallet.address(), BASE_ASSET_ID).await?;
        assert_eq!(coins.len(), 1);
</code></pre>
<h2 id="get-spendable-resources-owned-by-an-address"><a class="header" href="#get-spendable-resources-owned-by-an-address">Get spendable resources owned by an address</a></h2>
<p>The following example shows how to fetch resources owned by an address. First, you create a  <code>ResourceFilter</code> which specifies the target address, asset id, and amount. You can also define utxo ids and message ids that should be excluded when retrieving the resources:</p>
<pre><code class="language-rust ignore">pub struct ResourceFilter {
    pub from: Bech32Address,
    pub asset_id: AssetId,
    pub amount: u64,
    pub excluded_utxos: Vec&lt;UtxoId&gt;,
    pub excluded_message_ids: Vec&lt;MessageId&gt;,
}
</code></pre>
<p>The example uses default values for the asset id and the exclusion lists. This resolves to the base asset id and empty vectors for the id lists respectively:</p>
<pre><code class="language-rust ignore">        let filter = ResourceFilter {
            from: wallet.address().clone(),
            amount: 1,
            ..Default::default()
        };
        let spendable_resources = provider.get_spendable_resources(filter).await?;
        assert_eq!(spendable_resources.len(), 1);
</code></pre>
<h2 id="get-balances-from-an-address"><a class="header" href="#get-balances-from-an-address">Get balances from an address</a></h2>
<p>Get all the spendable balances of all assets for an address. This is different from getting the coins because we only return the numbers (the sum of UTXOs coins amount for each asset id) and not the UTXOs coins themselves.</p>
<pre><code class="language-rust ignore">        let _balances = provider.get_balances(wallet.address()).await?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="account"><a class="header" href="#account">Account</a></h1>
<p>The ViewOnlyAccount trait provides a common interface to query balances. </p>
<p>The Account trait, in addition to the above, also provides a common interface to retrieve spendable resources or transfer assets. When performing actions in the SDK that lead to a transaction, you will typically need to provide an account that will be used to allocate resources required by the transaction, including transaction fees.</p>
<p>Both traits are implemented by the following types:</p>
<ul>
<li><a href="getting-started/../getting-started/managing-wallets.html">Wallet</a></li>
<li><a href="getting-started/../getting-started/predicates.html">Predicate</a></li>
</ul>
<h2 id="transferring-assets"><a class="header" href="#transferring-assets">Transferring assets</a></h2>
<p>An account implements the following methods for transferring assets:</p>
<ul>
<li><code>transfer</code></li>
<li><code>force_transfer_to_contract</code></li>
<li><code>withdraw_to_base_layer</code></li>
</ul>
<p>The following examples are provided for a <code>Wallet</code> account. A <code>Predicate</code> account would work similarly, but you might need to set its predicate data before attempting to spend resources owned by it.</p>
<p>With <code>wallet.transfer</code> you can initiate a transaction to transfer an asset from your account to a target address.</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;

        // Setup 2 test wallets with 1 coin each
        let num_wallets = Some(2);
        let coins_per_wallet = Some(1);
        let coin_amount = Some(1);

        let wallets = launch_custom_provider_and_get_wallets(
            WalletsConfig::new(num_wallets, coins_per_wallet, coin_amount),
            None,
            None,
        )
        .await;

        // Transfer the base asset with amount 1 from wallet 1 to wallet 2
        let asset_id = Default::default();
        let (_tx_id, _receipts) = wallets[0]
            .transfer(wallets[1].address(), 1, asset_id, TxParameters::default())
            .await?;

        let wallet_2_final_coins = wallets[1].get_coins(BASE_ASSET_ID).await?;

        // Check that wallet 2 now has 2 coins
        assert_eq!(wallet_2_final_coins.len(), 2);

</code></pre>
<p>You can transfer assets to a contract via <code>wallet.force_transfer_to_contract</code>.</p>
<pre><code class="language-rust ignore">        // Check the current balance of the contract with id 'contract_id'
        let contract_balances = wallet
            .try_provider()?
            .get_contract_balances(&amp;contract_id)
            .await?;
        assert!(contract_balances.is_empty());

        // Transfer an amount of 300 to the contract
        let amount = 300;
        let asset_id = random_asset_id;
        let (_tx_id, _receipts) = wallet
            .force_transfer_to_contract(&amp;contract_id, amount, asset_id, TxParameters::default())
            .await?;

        // Check that the contract now has 1 coin
        let contract_balances = wallet
            .try_provider()?
            .get_contract_balances(&amp;contract_id)
            .await?;
        assert_eq!(contract_balances.len(), 1);

        let random_asset_id_key = format!(&quot;{random_asset_id:#x}&quot;);
        let random_asset_balance = contract_balances.get(&amp;random_asset_id_key).unwrap();
        assert_eq!(*random_asset_balance, 300);
</code></pre>
<p>For transferring assets to the base layer chain, you can use <code>wallet.withdraw_to_base_layer</code>.</p>
<pre><code class="language-rust ignore">        use std::str::FromStr;

        use fuels::prelude::*;

        let wallet = launch_provider_and_get_wallet().await;

        let amount = 1000;
        let base_layer_address =
            Address::from_str(&quot;0x4710162c2e3a95a6faff05139150017c9e38e5e280432d546fae345d6ce6d8fe&quot;)
                .expect(&quot;Invalid address.&quot;);
        let base_layer_address = Bech32Address::from(base_layer_address);
        // Transfer an amount of 1000 to the specified base layer address
        let (tx_id, msg_id, _receipts) = wallet
            .withdraw_to_base_layer(&amp;base_layer_address, amount, TxParameters::default())
            .await?;

        // Retrieve a message proof from the provider
        let proof = wallet
            .try_provider()?
            .get_message_proof(&amp;tx_id, &amp;msg_id)
            .await?
            .expect(&quot;Failed to retrieve message proof.&quot;);

        // Verify the amount and recipient
        assert_eq!(proof.amount, amount);
        assert_eq!(proof.recipient, base_layer_address);
</code></pre>
<p>The above example creates an <code>Address</code> from a string and converts it to a <code>Bech32Address</code>. Next, it calls <code>wallet.withdraw_to_base_layer</code> by providing the address, the amount to be transferred, and the transaction parameters. Lastly, to verify that the transfer succeeded, the relevant message proof is retrieved with <code>provider.get_message_proof,</code> and the amount and the recipient are verified.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-wallets"><a class="header" href="#managing-wallets">Managing wallets</a></h1>
<p>You can use wallets for many important things, for instance:</p>
<ol>
<li>Checking your balance;</li>
<li>Transferring coins to a destination address or contract;</li>
<li>Signing messages and transactions;</li>
<li>Paying for network fees when sending transactions or deploying smart contracts.</li>
</ol>
<p>The SDK gives you many different ways to create and access wallets. Let's explore these different approaches in the following sub-chapters.</p>
<blockquote>
<p><strong>Note:</strong> Keep in mind that you should never share your private/secret key. And in the case of wallets that were derived from a mnemonic phrase, never share your mnemonic phrase. If you're planning on storing the wallet on disk, do not store the plain private/secret key and do not store the plain mnemonic phrase. Instead, use <code>Wallet::encrypt</code> to encrypt its content first before saving it to disk.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-wallet-from-a-private-key"><a class="header" href="#creating-a-wallet-from-a-private-key">Creating a wallet from a private key</a></h1>
<p>A new wallet with a randomly generated private key can be created by supplying <code>Option&lt;Provider&gt;</code>.</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;

        // Use the test helper to setup a test provider.
        let (provider, _address) = setup_test_provider(vec![], vec![], None, None).await;

        // Create the wallet.
        let _wallet = WalletUnlocked::new_random(Some(provider));
</code></pre>
<p>Alternatively, you can create a wallet from a predefined <code>SecretKey</code>.</p>
<pre><code class="language-rust ignore">        use std::str::FromStr;

        use fuels::{accounts::fuel_crypto::SecretKey, prelude::*};

        // Use the test helper to setup a test provider.
        let (provider, _address) = setup_test_provider(vec![], vec![], None, None).await;

        // Setup the private key.
        let secret = SecretKey::from_str(
            &quot;5f70feeff1f229e4a95e1056e8b4d80d0b24b565674860cc213bdb07127ce1b1&quot;,
        )?;

        // Create the wallet.
        let _wallet = WalletUnlocked::new_from_private_key(secret, Some(provider));
</code></pre>
<blockquote>
<p>Note: if <code>None</code> is supplied instead of a provider, any transaction related to the wallet will result
in an error until a provider is linked with <code>set_provider()</code>. The optional parameter
enables defining owners (wallet addresses) of genesis coins before a provider is launched.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-wallet-from-mnemonic-phrases"><a class="header" href="#creating-a-wallet-from-mnemonic-phrases">Creating a wallet from mnemonic phrases</a></h1>
<p>A mnemonic phrase is a cryptographically-generated sequence of words that's used to derive a private key. For instance: <code>&quot;oblige salon price punch saddle immune slogan rare snap desert retire surprise&quot;;</code> would generate the address <code>0xdf9d0e6c6c5f5da6e82e5e1a77974af6642bdb450a10c43f0c6910a212600185</code>.</p>
<p>In addition to that, we also support <a href="https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets">Hierarchical Deterministic Wallets</a> and <a href="https://learnmeabitcoin.com/technical/derivation-paths">derivation paths</a>. You may recognize the string <code>&quot;m/44'/60'/0'/0/0&quot;</code> from somewhere; that's a derivation path. In simple terms, it's a way to derive many wallets from a single root wallet.</p>
<p>The SDK gives you two wallets from mnemonic instantiation methods: one that takes a derivation path (<code>Wallet::new_from_mnemonic_phrase_with_path</code>) and one that uses the default derivation path, in case you don't want or don't need to configure that (<code>Wallet::new_from_mnemonic_phrase</code>).</p>
<p>Here's how you can create wallets with both mnemonic phrases and derivation paths:</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;

        let phrase =
            &quot;oblige salon price punch saddle immune slogan rare snap desert retire surprise&quot;;

        // Use the test helper to setup a test provider.
        let (provider, _address) = setup_test_provider(vec![], vec![], None, None).await;

        // Create first account from mnemonic phrase.
        let _wallet = WalletUnlocked::new_from_mnemonic_phrase_with_path(
            phrase,
            Some(provider.clone()),
            &quot;m/44'/1179993420'/0'/0/0&quot;,
        )?;

        // Or with the default derivation path
        let wallet = WalletUnlocked::new_from_mnemonic_phrase(phrase, Some(provider))?;

        let expected_address = &quot;fuel17x9kg3k7hqf42396vqenukm4yf59e5k0vj4yunr4mae9zjv9pdjszy098t&quot;;

        assert_eq!(wallet.address().to_string(), expected_address);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallet-access"><a class="header" href="#wallet-access">Wallet Access</a></h1>
<p>The kinds of operations we can perform with a <code>Wallet</code> instance depend on
whether or not we have access to the wallet's private key.</p>
<p>In order to differentiate between <code>Wallet</code> instances that know their private key
and those that do not, we use the <code>WalletUnlocked</code> and <code>Wallet</code> types
respectively.</p>
<h2 id="wallet-states"><a class="header" href="#wallet-states">Wallet States</a></h2>
<p>The <code>WalletUnlocked</code> type represents a wallet whose private key is known and
stored internally in memory. A wallet must be of type <code>WalletUnlocked</code> in order
to perform operations that involve <a href="wallets/./signing.html">signing messages or
transactions</a>.</p>
<p>The <code>Wallet</code> type represents a wallet whose private key is <em>not</em> known or stored
in memory. Instead, <code>Wallet</code> only knows its public address. A <code>Wallet</code> cannot be
used to sign transactions, however it may still perform a whole suite of useful
operations including listing transactions, assets, querying balances, and so on.</p>
<p>Note that the <code>WalletUnlocked</code> type provides a <code>Deref</code> implementation targeting
its inner <code>Wallet</code> type. This means that all methods available on the <code>Wallet</code>
type are also available on the <code>WalletUnlocked</code> type. In other words,
<code>WalletUnlocked</code> can be thought of as a thin wrapper around <code>Wallet</code> that
provides greater access via its private key.</p>
<h2 id="transitioning-states"><a class="header" href="#transitioning-states">Transitioning States</a></h2>
<p>A <code>Wallet</code> instance can be unlocked by providing the private key:</p>
<pre><code class="language-rust ignore">let wallet_unlocked = wallet_locked.unlock(private_key);
</code></pre>
<p>A <code>WalletUnlocked</code> instance can be locked using the <code>lock</code> method:</p>
<pre><code class="language-rust ignore">let wallet_locked = wallet_unlocked.lock();
</code></pre>
<p>Most wallet constructors that create or generate a new wallet are provided on
the <code>WalletUnlocked</code> type. Consider <code>lock</code>ing the wallet after the new private
key has been handled in order to reduce the scope in which the wallet's private
key is stored in memory.</p>
<h2 id="design-guidelines"><a class="header" href="#design-guidelines">Design Guidelines</a></h2>
<p>When designing APIs that accept a wallet as an input, we should think carefully
about the kind of access that we require. API developers should aim to minimise
their usage of <code>WalletUnlocked</code> in order to ensure private keys are stored in
memory no longer than necessary to reduce the surface area for attacks and
vulnerabilities in downstream libraries and applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encrypting-and-storing-wallets"><a class="header" href="#encrypting-and-storing-wallets">Encrypting and storing wallets</a></h1>
<h2 id="creating-a-wallet-and-storing-an-encrypted-json-wallet-on-disk"><a class="header" href="#creating-a-wallet-and-storing-an-encrypted-json-wallet-on-disk">Creating a wallet and storing an encrypted JSON wallet on disk</a></h2>
<p>You can also manage a wallet using <a href="https://cryptobook.nakov.com/symmetric-key-ciphers/ethereum-wallet-encryption">JSON wallets</a> that are securely encrypted and stored on the disk. This makes it easier to manage multiple wallets, especially for testing purposes.</p>
<p>You can create a random wallet and, at the same time, encrypt and store it. Then, later, you can recover the wallet if you know the master password:</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;

        let dir = std::env::temp_dir();
        let mut rng = rand::thread_rng();

        // Use the test helper to setup a test provider.
        let (provider, _address) = setup_test_provider(vec![], vec![], None, None).await;

        let password = &quot;my_master_password&quot;;

        // Create a wallet to be stored in the keystore.
        let (_wallet, uuid) =
            WalletUnlocked::new_from_keystore(&amp;dir, &amp;mut rng, password, Some(provider.clone()))?;

        let path = dir.join(uuid);

        let _recovered_wallet = WalletUnlocked::load_keystore(path, password, Some(provider))?;
</code></pre>
<h2 id="encrypting-and-storing-a-wallet-created-from-a-mnemonic-or-private-key"><a class="header" href="#encrypting-and-storing-a-wallet-created-from-a-mnemonic-or-private-key">Encrypting and storing a wallet created from a mnemonic or private key</a></h2>
<p>If you have already created a wallet using a mnemonic phrase or a private key, you can also encrypt it and save it to disk:</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;

        let dir = std::env::temp_dir();

        let phrase =
            &quot;oblige salon price punch saddle immune slogan rare snap desert retire surprise&quot;;

        // Use the test helper to setup a test provider.
        let (provider, _address) = setup_test_provider(vec![], vec![], None, None).await;

        // Create first account from mnemonic phrase.
        let wallet = WalletUnlocked::new_from_mnemonic_phrase(phrase, Some(provider))?;

        let password = &quot;my_master_password&quot;;

        // Encrypts and stores it on disk. Can be recovered using `Wallet::load_keystore`.
        let _uuid = wallet.encrypt(&amp;dir, password)?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checking-balances-and-coins"><a class="header" href="#checking-balances-and-coins">Checking balances and coins</a></h1>
<p>First, one should remember that, with UTXOs, each <em>coin</em> is unique. Each UTXO corresponds to a unique <em>coin</em>, and said <em>coin</em> has a corresponding <em>amount</em> (the same way a dollar bill has either 10$ or 5$ face value). So, when you want to query the balance for a given asset ID, you want to query the sum of the amount in each unspent coin. This querying is done very easily with a wallet:</p>
<pre><code class="language-rust ignore">        let asset_id: AssetId = BASE_ASSET_ID;
        let balance: u64 = wallet.get_asset_balance(&amp;asset_id).await?;
</code></pre>
<p>If you want to query all the balances (i.e., get the balance for each asset ID in that wallet), then it is as simple as:</p>
<pre><code class="language-rust ignore">        let balances: HashMap&lt;String, u64&gt; = wallet.get_balances().await?;
</code></pre>
<p>The return type is a <code>HashMap</code>, where the key is the <em>asset ID's</em> hex string, and the value is the corresponding balance. For example, we can get the base asset balance with:</p>
<pre><code class="language-rust ignore">        let asset_id_key = format!(&quot;{asset_id:#x}&quot;);
        let asset_balance = balances.get(&amp;asset_id_key).unwrap();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-test-wallets"><a class="header" href="#setting-up-test-wallets">Setting up test wallets</a></h1>
<p>You'll often want to create one or more test wallets when testing your contracts. Here's how to do it.</p>
<h2 id="setting-up-multiple-test-wallets"><a class="header" href="#setting-up-multiple-test-wallets">Setting up multiple test wallets</a></h2>
<p>If you need multiple test wallets, they can be set up as follows:</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;
        // This helper will launch a local node and provide 10 test wallets linked to it.
        // The initial balance defaults to 1 coin per wallet with an amount of 1_000_000_000
        let wallets =
            launch_custom_provider_and_get_wallets(WalletsConfig::default(), None, None).await;
</code></pre>
<p>You can customize your test wallets via <code>WalletsConfig</code>.</p>
<pre><code class="language-rust ignore">        let num_wallets = 5;
        let coins_per_wallet = 3;
        let amount_per_coin = 100;

        let config = WalletsConfig::new(
            Some(num_wallets),
            Some(coins_per_wallet),
            Some(amount_per_coin),
        );
        // Launches a local node and provides test wallets as specified by the config
        let wallets = launch_custom_provider_and_get_wallets(config, None, None).await;
</code></pre>
<blockquote>
<p><strong>Note</strong> Wallets generated with <code>launch_provider_and_get_wallet</code> or <code>launch_custom_provider_and_get_wallets</code>
will have deterministic addresses.</p>
</blockquote>
<h2 id="setting-up-a-test-wallet-with-multiple-random-assets"><a class="header" href="#setting-up-a-test-wallet-with-multiple-random-assets">Setting up a test wallet with multiple random assets</a></h2>
<p>You can create a test wallet containing multiple assets (including the base asset to pay for gas).</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;
        let mut wallet = WalletUnlocked::new_random(None);
        let num_assets = 5; // 5 different assets
        let coins_per_asset = 10; // Per asset id, 10 coins in the wallet
        let amount_per_coin = 15; // For each coin (UTXO) of the asset, amount of 15

        let (coins, asset_ids) = setup_multiple_assets_coins(
            wallet.address(),
            num_assets,
            coins_per_asset,
            amount_per_coin,
        );
        let (provider, _socket_addr) = setup_test_provider(coins.clone(), vec![], None, None).await;
        wallet.set_provider(provider);
</code></pre>
<ul>
<li>coins: <code>Vec&lt;(UtxoId, Coin)&gt;</code> has num_assets * coins_per_assets coins (UTXOs)</li>
<li>asset_ids: <code>Vec&lt;AssetId&gt;</code> contains the num_assets randomly generated <code>AssetId</code>s (always includes the base asset)</li>
</ul>
<h2 id="setting-up-a-test-wallet-with-multiple-custom-assets"><a class="header" href="#setting-up-a-test-wallet-with-multiple-custom-assets">Setting up a test wallet with multiple custom assets</a></h2>
<p>You can also create assets with specific <code>AssetId</code>s, coin amounts, and number of coins.</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;
        use rand::Fill;

        let mut wallet = WalletUnlocked::new_random(None);
        let mut rng = rand::thread_rng();

        let asset_base = AssetConfig {
            id: BASE_ASSET_ID,
            num_coins: 2,
            coin_amount: 4,
        };

        let mut asset_id_1 = AssetId::zeroed();
        asset_id_1.try_fill(&amp;mut rng)?;
        let asset_1 = AssetConfig {
            id: asset_id_1,
            num_coins: 6,
            coin_amount: 8,
        };

        let mut asset_id_2 = AssetId::zeroed();
        asset_id_2.try_fill(&amp;mut rng)?;
        let asset_2 = AssetConfig {
            id: asset_id_2,
            num_coins: 10,
            coin_amount: 12,
        };

        let assets = vec![asset_base, asset_1, asset_2];

        let coins = setup_custom_assets_coins(wallet.address(), &amp;assets);
        let (provider, _socket_addr) = setup_test_provider(coins, vec![], None, None).await;
        wallet.set_provider(provider);
</code></pre>
<p>This can also be achieved directly with the <code>WalletsConfig</code>.</p>
<pre><code class="language-rust ignore">        let num_wallets = 1;
        let wallet_config = WalletsConfig::new_multiple_assets(num_wallets, assets);
        let wallets = launch_custom_provider_and_get_wallets(wallet_config, None, None).await;
</code></pre>
<blockquote>
<p><strong>Note</strong> In this case, you need to manually add the base asset and the corresponding number of
coins and coin amount</p>
</blockquote>
<h2 id="setting-up-assets"><a class="header" href="#setting-up-assets">Setting up assets</a></h2>
<p>The Fuel blockchain holds many different assets; you can create your asset with its unique <code>AssetId</code> or create random assets for testing purposes.</p>
<p>You can use only one asset to pay for transaction fees and gas: the base asset, whose AssetId is <code>0x000...0</code>, a 32-byte zeroed value.</p>
<p>For testing purposes, you can configure coins and amounts for assets. You can use <code>setup_multiple_assets_coins</code>:</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;
        let mut wallet = WalletUnlocked::new_random(None);
        let num_assets = 5; // 5 different assets
        let coins_per_asset = 10; // Per asset id, 10 coins in the wallet
        let amount_per_coin = 15; // For each coin (UTXO) of the asset, amount of 15

        let (coins, asset_ids) = setup_multiple_assets_coins(
            wallet.address(),
            num_assets,
            coins_per_asset,
            amount_per_coin,
        );
</code></pre>
<blockquote>
<p><strong>Note</strong> If setting up multiple assets, one of these assets will always be the base asset.</p>
</blockquote>
<p>If you want to create coins only with the base asset, then you can use:</p>
<pre><code class="language-rust ignore">        let wallet = WalletUnlocked::new_random(None);

        // How many coins in our wallet.
        let number_of_coins = 1;

        // The amount/value in each coin in our wallet.
        let amount_per_coin = 3;

        let coins = setup_single_asset_coins(
            wallet.address(),
            BASE_ASSET_ID,
            number_of_coins,
            amount_per_coin,
        );
</code></pre>
<blockquote>
<p><strong>Note</strong> Choosing a large number of coins and assets for <code>setup_multiple_assets_coins</code> or <code>setup_single_asset_coins</code> can lead to considerable runtime for these methods. This will be improved in the future but for now, we recommend using up to <strong>1_000_000</strong> coins, or <strong>1000</strong> coins and assets simultaneously.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signing"><a class="header" href="#signing">Signing</a></h1>
<p>Once you've instantiated your wallet in an unlocked state using one of the previously discussed methods, you can sign a message with <code>wallet.sign_message</code>. Below is a full example of how to sign and recover a message.</p>
<pre><code class="language-rust ignore">        let mut rng = StdRng::seed_from_u64(2322u64);
        let mut secret_seed = [0u8; 32];
        rng.fill_bytes(&amp;mut secret_seed);

        let secret = unsafe { SecretKey::from_bytes_unchecked(secret_seed) };

        // Create a wallet using the private key created above.
        let wallet = WalletUnlocked::new_from_private_key(secret, None);

        let message = &quot;my message&quot;;

        let signature = wallet.sign_message(message).await?;

        // Check if signature is what we expect it to be
        assert_eq!(signature, Signature::from_str(&quot;0x8eeb238db1adea4152644f1cd827b552dfa9ab3f4939718bb45ca476d167c6512a656f4d4c7356bfb9561b14448c230c6e7e4bd781df5ee9e5999faa6495163d&quot;)?);

        // Recover address that signed the message
        let message = Message::new(message);
        let recovered_address = signature.recover(&amp;message)?;

        assert_eq!(wallet.address().hash(), recovered_address.hash());

        // Verify signature
        signature.verify(&amp;recovered_address, &amp;message)?;
        Ok(())
</code></pre>
<p>You can also sign a <em>transaction</em> by using <code>wallet.sign_transaction</code>. Below is a full example of how to sign and recover a transaction.</p>
<pre><code class="language-rust ignore">        let secret = SecretKey::from_str(
            &quot;5f70feeff1f229e4a95e1056e8b4d80d0b24b565674860cc213bdb07127ce1b1&quot;,
        )?;
        let wallet = WalletUnlocked::new_from_private_key(secret, None);

        // Set up a dummy transaction.
        let input_coin = Input::coin_signed(
            UtxoId::new(Bytes32::zeroed(), 0),
            Address::from_str(
                &quot;0xf1e92c42b90934aa6372e30bc568a326f6e66a1a0288595e6e3fbd392a4f3e6e&quot;,
            )?,
            10000000,
            AssetId::from([0u8; 32]),
            TxPointer::default(),
            0,
            0,
        );

        let output_coin = Output::coin(
            Address::from_str(
                &quot;0xc7862855b418ba8f58878db434b21053a61a2025209889cc115989e8040ff077&quot;,
            )?,
            1,
            AssetId::from([0u8; 32]),
        );

        let mut tx: ScriptTransaction = FuelTransaction::script(
            0,
            1000000,
            0,
            hex::decode(&quot;24400000&quot;)?,
            vec![],
            vec![input_coin],
            vec![output_coin],
            vec![],
        )
        .into();

        // Sign the transaction.
        let signature = wallet.sign_transaction(&amp;mut tx)?;
        let message = unsafe { Message::from_bytes_unchecked(*tx.id()) };

        // Check if signature is what we expect it to be
        assert_eq!(signature, Signature::from_str(&quot;34482a581d1fe01ba84900581f5321a8b7d4ec65c3e7ca0de318ff8fcf45eb2c793c4b99e96400673e24b81b7aa47f042cad658f05a84e2f96f365eb0ce5a511&quot;)?);

        // Recover address that signed the transaction
        let recovered_address = signature.recover(&amp;message)?;

        assert_eq!(wallet.address().hash(), recovered_address.hash());

        // Verify signature
        signature.verify(&amp;recovered_address, &amp;message)?;
        Ok(())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-bindings-with-abigen"><a class="header" href="#generating-bindings-with-abigen">Generating bindings with abigen!</a></h1>
<p>You might have noticed this snippet in the previous sections:</p>
<pre><code class="language-rust ignore">        abigen!(Contract(
            name = &quot;MyContract&quot;,
            abi = &quot;packages/fuels/tests/contracts/contract_test/out/debug/contract_test-abi.json&quot;
        ));
</code></pre>
<p>The SDK lets you transform ABI methods of a smart contract, specified as JSON objects (which you can get from <a href="https://github.com/FuelLabs/sway/tree/master/forc">Forc</a>), into Rust structs and methods that are type-checked at compile time.
In order to call your contracts, scripts or predicates, you first need to generate the Rust bindings for them. </p>
<p>The following subsections contain more details about the <code>abigen!</code> syntax and the code generated from it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-json-abi-file"><a class="header" href="#the-json-abi-file">The JSON ABI file</a></h1>
<p>Whether you want to deploy or connect to a pre-existing smart contract, the JSON ABI file is extremely important: it's what tells the SDK about the <a href="https://fuellabs.github.io/sway/master/introduction/sway_quickstart.html#abi">ABI methods</a> in your smart contracts.</p>
<p>For the same example Sway code as above:</p>
<pre><code class="language-Rust">contract;

abi MyContract {
    fn test_function() -&gt; bool;
}

impl MyContract for Contract {
    fn test_function() -&gt; bool {
        true
    }
}
</code></pre>
<p>The JSON ABI file looks like this:</p>
<pre><code class="language-json">$ cat out/debug/my-test-abi.json
[
  {
    &quot;type&quot;: &quot;function&quot;,
    &quot;inputs&quot;: [],
    &quot;name&quot;: &quot;test_function&quot;,
    &quot;outputs&quot;: [
      {
        &quot;name&quot;: &quot;&quot;,
        &quot;type&quot;: &quot;bool&quot;,
        &quot;components&quot;: null
      }
    ]
  }
]
</code></pre>
<p>The Fuel Rust SDK will take this file as input and generate equivalent methods (and custom types if applicable) that you can call from your Rust code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abigen"><a class="header" href="#abigen">abigen!</a></h1>
<p><code>abigen!</code> is a procedural macro -- it generates code. It accepts inputs in the format of:</p>
<pre><code class="language-text">ProgramType(name=&quot;MyProgramType&quot;, abi=&quot;my_program-abi.json&quot;)...
</code></pre>
<p>where:</p>
<ul>
<li>
<p><code>ProgramType</code> is one of: <code>Contract</code>, <code>Script</code> or <code>Predicate</code>,</p>
</li>
<li>
<p><code>name</code> is the name that will be given to the generated bindings,</p>
</li>
<li>
<p><code>abi</code> is either a path to the json abi file or its actual contents.</p>
</li>
</ul>
<hr />
<p>So, an <code>abigen!</code> which generates bindings for two contracts and one script looks like this:</p>
<pre><code class="language-rust ignore">        abigen!(
            Contract(name=&quot;ContractA&quot;, abi=&quot;packages/fuels/tests/bindings/sharing_types/contract_a/out/debug/contract_a-abi.json&quot;),
            Contract(name=&quot;ContractB&quot;, abi=&quot;packages/fuels/tests/bindings/sharing_types/contract_b/out/debug/contract_b-abi.json&quot;),
            Script(name=&quot;MyScript&quot;, abi=&quot;packages/fuels/tests/scripts/arguments/out/debug/arguments-abi.json&quot;),
            Predicate(name=&quot;MyPredicateEncoder&quot;, abi=&quot;packages/fuels/tests/predicates/basic_predicate/out/debug/basic_predicate-abi.json&quot;),
        );
</code></pre>
<h2 id="how-does-the-generated-code-look"><a class="header" href="#how-does-the-generated-code-look">How does the generated code look?</a></h2>
<p>A rough overview:</p>
<pre><code class="language-rust ignore">pub mod abigen_bindings {
    pub mod contract_a_mod {
        struct SomeCustomStruct{/*...*/};
        // other custom types used in the contract

        struct ContractA {/*...*/};
        impl ContractA {/*...*/};
        // ...
    }
    pub mod contract_b_mod {
        // ...
    }
    pub mod my_script_mod {
        // ...
    }
    pub mod my_predicate_mod{
        // ...
    }
    pub mod shared_types{
        // ...
    }
}

pub use contract_a_mod::{/*..*/};
pub use contract_b_mod::{/*..*/};
pub use my_predicate_mod::{/*..*/};
pub use shared_types::{/*..*/};
</code></pre>
<p>Each <code>ProgramType</code> gets its own <code>mod</code> based on the <code>name</code> given in the <code>abigen!</code>. Inside the respective mods, the custom types used by that program are generated, and the bindings through which the actual calls can be made.</p>
<p>One extra <code>mod</code> called <code>shared_types</code> is generated if <code>abigen!</code> detects that the given programs share types. Instead of each <code>mod</code> regenerating the type for itself, the type is lifted out into the <code>shared_types</code> module, generated only once, and then shared between all program bindings that use it. Reexports are added to each mod so that even if a type is deemed shared, you can still access it as though each <code>mod</code> had generated the type for itself (i.e. <code>my_contract_mod::SharedType</code>).</p>
<p>A type is deemed shared if its name and definition match up. This can happen either because you've used the same library (a custom one or a type from the stdlib) or because you've happened to define the exact same type.</p>
<p>Finally, <code>pub use</code> statements are inserted, so you don't have to fully qualify the generated types. To avoid conflict, only types that have unique names will get a <code>pub use</code> statement. If you find rustc can't find your type, it might just be that there is another generated type with the same name. To fix the issue just qualify the path by doing <code>abigen_bindings::whatever_contract_mod::TheType</code>.</p>
<blockquote>
<p><strong>Note:</strong>
It is <strong>highly</strong> encouraged that you generate all your bindings in one <code>abigen!</code> call. Doing it in this manner will allow type sharing and avoid name collisions you'd normally get when calling <code>abigen!</code> multiple times inside the same namespace. If you choose to proceed otherwise, keep in mind the generated code overview presented above and appropriately separate the <code>abigen!</code> calls into different modules to resolve the collision.</p>
</blockquote>
<h3 id="type-paths"><a class="header" href="#type-paths">Type paths</a></h3>
<p>Normally when using types from libraries in your contract, script or predicate, they'll be generated directly under the main <code>mod</code> of your program bindings, i.e. a type in a contract binding <code>MyContract</code> imported from a library <code>some_library</code> would be generated under <code>abigen_bindings::my_contract_mod::SomeLibraryType</code>.</p>
<p>This can cause problems if you happen to have two types with the same name in different libraries of your program.</p>
<p>This behavior can be changed to include the library path by compiling your Sway project with the following:</p>
<pre><code>forc build --json-abi-with-callpaths
</code></pre>
<p>Now the type from the previous example will be generated under <code>abigen_bindings::my_contract_mod::some_library::SomeLibraryType</code>.</p>
<p>This might only become relevant if your type isn't reexported. This can happen, as explained previously, if your type does not have a unique name across all bindings inside one <code>abigen!</code> call. You'll then need to fully qualify the access to it.</p>
<p>Including type paths will eventually become the default and the flag will be removed.</p>
<h2 id="using-the-bindings"><a class="header" href="#using-the-bindings">Using the bindings</a></h2>
<p>Let's look at a contract with two methods: <code>initialize_counter(arg: u64) -&gt; u64</code> and <code>increment_counter(arg: u64) -&gt; u64</code>, with the following JSON ABI:</p>
<pre><code class="language-json ignore">{
  &quot;types&quot;: [
    {
      &quot;typeId&quot;: 0,
      &quot;type&quot;: &quot;u64&quot;,
      &quot;components&quot;: null,
      &quot;typeParameters&quot;: null
    }
  ],
  &quot;functions&quot;: [
    {
      &quot;inputs&quot;: [
        {
          &quot;name&quot;: &quot;value&quot;,
          &quot;type&quot;: 0,
          &quot;typeArguments&quot;: null
        }
      ],
      &quot;name&quot;: &quot;initialize_counter&quot;,
      &quot;output&quot;: {
        &quot;name&quot;: &quot;&quot;,
        &quot;type&quot;: 0,
        &quot;typeArguments&quot;: null
      }
    },
    {
      &quot;inputs&quot;: [
        {
          &quot;name&quot;: &quot;value&quot;,
          &quot;type&quot;: 0,
          &quot;typeArguments&quot;: null
        }
      ],
      &quot;name&quot;: &quot;increment_counter&quot;,
      &quot;output&quot;: {
        &quot;name&quot;: &quot;&quot;,
        &quot;type&quot;: 0,
        &quot;typeArguments&quot;: null
      }
    }
  ]
}
</code></pre>
<p>By doing this:</p>
<pre><code class="language-rust ignore">            use fuels::prelude::*;
            // Replace with your own JSON abi path (relative to the root of your crate)
            abigen!(Contract(
                name = &quot;MyContractName&quot;,
                abi = &quot;examples/rust_bindings/src/abi.json&quot;
            ));
</code></pre>
<p>or this:</p>
<pre><code class="language-rust ignore">            use fuels::prelude::*;
            abigen!(Contract(
                name = &quot;MyContract&quot;,
                abi = r#&quot;
            {
                &quot;types&quot;: [
                  {
                    &quot;typeId&quot;: 0,
                    &quot;type&quot;: &quot;u64&quot;,
                    &quot;components&quot;: null,
                    &quot;typeParameters&quot;: null
                  }
                ],
                &quot;functions&quot;: [
                  {
                    &quot;inputs&quot;: [
                      {
                        &quot;name&quot;: &quot;value&quot;,
                        &quot;type&quot;: 0,
                        &quot;typeArguments&quot;: null
                      }
                    ],
                    &quot;name&quot;: &quot;initialize_counter&quot;,
                    &quot;output&quot;: {
                      &quot;name&quot;: &quot;&quot;,
                      &quot;type&quot;: 0,
                      &quot;typeArguments&quot;: null
                    }
                  },
                  {
                    &quot;inputs&quot;: [
                      {
                        &quot;name&quot;: &quot;value&quot;,
                        &quot;type&quot;: 0,
                        &quot;typeArguments&quot;: null
                      }
                    ],
                    &quot;name&quot;: &quot;increment_counter&quot;,
                    &quot;output&quot;: {
                      &quot;name&quot;: &quot;&quot;,
                      &quot;type&quot;: 0,
                      &quot;typeArguments&quot;: null
                    }
                  }
                ]
              }
            &quot;#
            ));
</code></pre>
<p>you'll generate this (shortened for brevity's sake):</p>
<pre><code class="language-rust ignore">pub mod abigen_bindings {
    pub mod my_contract_mod {
        pub struct MyContract&lt;T: Account&gt; {
            contract_id: Bech32ContractId,
            account: T,
            log_decoder: LogDecoder,
        }
        impl&lt;T: Account&gt; MyContract&lt;T&gt; {
            pub fn new(contract_id: Bech32ContractId, account: T) -&gt; Self {
                let log_decoder = LogDecoder {
                    type_lookup: logs::log_type_lookup(&amp;[], contract_id.clone().into()),
                };
                Self {
                    contract_id,
                    account,
                    log_decoder,
                }
            }
            pub fn contract_id(&amp;self) -&gt; &amp;Bech32ContractId {
                &amp;self.contract_id
            }
            pub fn account(&amp;self) -&gt; T {
                self.account.clone()
            }
            pub fn with_account&lt;U: Account&gt;(&amp;self, mut account: U) -&gt; Result&lt;MyContract&lt;U&gt;&gt; {
                Ok(MyContract {
                    contract_id: self.contract_id.clone(),
                    account,
                    log_decoder: self.log_decoder.clone(),
                })
            }
            pub async fn get_balances(&amp;self) -&gt; Result&lt;HashMap&lt;String, u64&gt;&gt; {
                ViewOnlyAccount::try_provider(&amp;self.account)?
                    .get_contract_balances(&amp;self.contract_id)
                    .await
                    .map_err(Into::into)
            }
            pub fn methods(&amp;self) -&gt; MyContractMethods&lt;T&gt; {
                MyContractMethods {
                    contract_id: self.contract_id.clone(),
                    account: self.account.clone(),
                    log_decoder: self.log_decoder.clone(),
                }
            }
        }
        pub struct MyContractMethods&lt;T: Account&gt; {
            contract_id: Bech32ContractId,
            account: T,
            log_decoder: LogDecoder,
        }
        impl&lt;T: Account&gt; MyContractMethods&lt;T&gt; {
            #[doc = &quot;Calls the contract's `initialize_counter` function&quot;]
            pub fn initialize_counter(&amp;self, value: u64) -&gt; ContractCallHandler&lt;T, u64&gt; {
                Contract::method_hash(
                    self.contract_id.clone(),
                    self.account,
                    function_selector::resolve_fn_selector(
                        &quot;initialize_counter&quot;,
                        &amp;[&lt;u64 as Parameterize&gt;::param_type()],
                    ),
                    &amp;[Tokenizable::into_token(value)],
                    self.log_decoder.clone(),
                    false,
                )
                .expect(&quot;method not found (this should never happen)&quot;)
            }
            #[doc = &quot;Calls the contract's `increment_counter` function&quot;]
            pub fn increment_counter(&amp;self, value: u64) -&gt; ContractCallHandler&lt;T, u64&gt; {
                Contract::method_hash(
                    self.contract_id.clone(),
                    self.account,
                    function_selector::resolve_fn_selector(
                        &quot;increment_counter&quot;,
                        &amp;[&lt;u64 as Parameterize&gt;::param_type()],
                    ),
                    &amp;[Tokenizable::into_token(value)],
                    self.log_decoder.clone(),
                    false,
                )
                .expect(&quot;method not found (this should never happen)&quot;)
            }
        }
        impl&lt;T: Account&gt; SettableContract for MyContract&lt;T&gt; {
            fn id(&amp;self) -&gt; Bech32ContractId {
                self.contract_id.clone()
            }
            fn log_decoder(&amp;self) -&gt; LogDecoder {
                self.log_decoder.clone()
            }
        }
        #[derive(Clone, Debug, Default)]
        pub struct MyContractConfigurables {
            offsets_with_data: Vec&lt;(u64, Vec&lt;u8&gt;)&gt;,
        }
        impl MyContractConfigurables {
            pub fn new() -&gt; Self {
                Default::default()
            }
        }
        impl From&lt;MyContractConfigurables&gt; for Configurables {
            fn from(config: MyContractConfigurables) -&gt; Self {
                Configurables::new(config.offsets_with_data)
            }
        }
    }
}

pub use abigen_bindings::my_contract_mod::MyContract;
pub use abigen_bindings::my_contract_mod::MyContractConfigurables;
pub use abigen_bindings::my_contract_mod::MyContractMethods;
</code></pre>
<blockquote>
<p><strong>Note:</strong> that is all <strong>generated</strong> code. No need to write any of that. Ever. The generated code might look different from one version to another, this is just an example to give you an idea of what it looks like.</p>
</blockquote>
<p>Then, you're able to use it to call the actual methods on the deployed contract:</p>
<pre><code class="language-rust ignore">        // This will generate your contract's methods onto `MyContract`.
        // This means an instance of `MyContract` will have access to all
        // your contract's methods that are running on-chain!
        abigen!(Contract(
            name = &quot;MyContract&quot;,
            abi = &quot;packages/fuels/tests/contracts/contract_test/out/debug/contract_test-abi.json&quot;
        ));

        // This is an instance of your contract which you can use to make calls to your functions
        let contract_instance = MyContract::new(contract_id_2, wallet);

        let response = contract_instance
            .methods()
            .initialize_counter(42) // Build the ABI call
            .call() // Perform the network call
            .await?;

        assert_eq!(42, response.value);

        let response = contract_instance
            .methods()
            .increment_counter(10)
            .call()
            .await?;

        assert_eq!(52, response.value);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-contracts"><a class="header" href="#deploying-contracts">Deploying contracts</a></h1>
<p>There are two main ways of working with contracts in the SDK: deploying a contract with SDK or using the SDK to interact with existing contracts.</p>
<h2 id="deploying-a-contract-binary"><a class="header" href="#deploying-a-contract-binary">Deploying a contract binary</a></h2>
<p>Once you've written a contract in Sway and compiled it with <code>forc build</code> (read <a href="https://fuellabs.github.io/sway/master/introduction/sway_quickstart.html">here</a> for more on how to work with Sway), you'll have in your hands two important artifacts: the compiled binary file and the JSON ABI file.</p>
<p>Below is how you can deploy your contracts using the SDK. For more details about each component in this process, read <a href="getting-started/../abigen/the-abigen-macro.html">The abigen macro</a>, <a href="getting-started/../contracts/the-fuelvm-binary-file.html">The FuelVM binary file</a>, and <a href="getting-started/../abigen/the-json-abi-file.html">The JSON ABI file</a>.</p>
<p>First, the <code>Contract::load_from</code> function is used to load a contract binary with a <code>LoadConfiguration</code>. If you are only interested in a single instance of your contract, use the default configuration: <code>LoadConfiguration::default()</code>. After the contract binary is loaded, you can use the <code>deploy()</code> method to deploy the contract to the blockchain.</p>
<pre><code class="language-rust ignore">        // This helper will launch a local node and provide a test wallet linked to it
        let wallet = launch_provider_and_get_wallet().await;

        // This will load and deploy your contract binary to the chain so that its ID can
        // be used to initialize the instance
        let contract_id = Contract::load_from(
            &quot;../../packages/fuels/tests/contracts/contract_test/out/debug/contract_test.bin&quot;,
            LoadConfiguration::default(),
        )?
        .deploy(&amp;wallet, TxParameters::default())
        .await?;

        println!(&quot;Contract deployed @ {contract_id}&quot;);
</code></pre>
<p>Alternatively, you can use <code>LoadConfiguration</code> to configure how the contract is loaded. <code>LoadConfiguration</code> let's you:</p>
<ul>
<li>Load the same contract binary with <code>Salt</code> to get a new <code>contract_id</code></li>
<li>Change the contract's storage slots</li>
<li>Update the contract's configurables
<blockquote>
<p>Note: The next section will give more information on how <code>configurables</code> can be used.</p>
</blockquote>
</li>
</ul>
<p>Additionally, you can set custom <code>TxParameters</code> when deploying the loaded contract.</p>
<pre><code class="language-rust ignore">        // Optional: Add `Salt`
        let rng = &amp;mut StdRng::seed_from_u64(2322u64);
        let salt: [u8; 32] = rng.gen();

        // Optional: Configure storage
        let key = Bytes32::from([1u8; 32]);
        let value = Bytes32::from([2u8; 32]);
        let storage_slot = StorageSlot::new(key, value);
        let storage_configuration = StorageConfiguration::from(vec![storage_slot]);
        let configuration = LoadConfiguration::default()
            .set_storage_configuration(storage_configuration)
            .set_salt(salt);

        // Optional: Configure deployment parameters
        let tx_parameters = TxParameters::default()
            .set_gas_price(0)
            .set_gas_limit(1_000_000)
            .set_maturity(0);

        let contract_id_2 = Contract::load_from(
            &quot;../../packages/fuels/tests/contracts/contract_test/out/debug/contract_test.bin&quot;,
            configuration,
        )?
        .deploy(&amp;wallet, tx_parameters)
        .await?;

        println!(&quot;Contract deployed @ {contract_id_2}&quot;);
</code></pre>
<p>After the contract is deployed, you can use the contract's methods like this:</p>
<pre><code class="language-rust ignore">        // This will generate your contract's methods onto `MyContract`.
        // This means an instance of `MyContract` will have access to all
        // your contract's methods that are running on-chain!
        abigen!(Contract(
            name = &quot;MyContract&quot;,
            abi = &quot;packages/fuels/tests/contracts/contract_test/out/debug/contract_test-abi.json&quot;
        ));

        // This is an instance of your contract which you can use to make calls to your functions
        let contract_instance = MyContract::new(contract_id_2, wallet);

        let response = contract_instance
            .methods()
            .initialize_counter(42) // Build the ABI call
            .call() // Perform the network call
            .await?;

        assert_eq!(42, response.value);

        let response = contract_instance
            .methods()
            .increment_counter(10)
            .call()
            .await?;

        assert_eq!(52, response.value);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configurable-constants"><a class="header" href="#configurable-constants">Configurable constants</a></h1>
<p>In Sway, you can define <code>configurable</code> constants which can be changed during the contract deployment in the SDK. Here is an example how the constants are defined.</p>
<pre><code class="language-rust ignore">contract;

enum EnumWithGeneric&lt;D&gt; {
    VariantOne: D,
    VariantTwo: (),
}

struct StructWithGeneric&lt;D&gt; {
    field_1: D,
    field_2: u64,
}

configurable {
    U8: u8 = 8u8,
    BOOL: bool = true,
    ARRAY: [u32; 3] = [253u32, 254u32, 255u32],
    STR_4: str[4] = &quot;fuel&quot;,
    STRUCT: StructWithGeneric&lt;u8&gt; = StructWithGeneric {
        field_1: 8u8,
        field_2: 16,
    },
    ENUM: EnumWithGeneric&lt;bool&gt; = EnumWithGeneric::VariantOne(true),
}

abi TestContract {
    fn return_configurables() -&gt; (u8, bool, [u32; 3], str[4], StructWithGeneric&lt;u8&gt;, EnumWithGeneric&lt;bool&gt;);
}

impl TestContract for Contract {
    fn return_configurables(    ) -&gt; (u8, bool, [u32; 3], str[4], StructWithGeneric&lt;u8&gt;, EnumWithGeneric&lt;bool&gt;) {
        (U8, BOOL, ARRAY, STR_4, STRUCT, ENUM)
    }
}
</code></pre>
<p>Each of the configurable constants will get a dedicated <code>set</code> method in the SDK. For example, the constant <code>STR_4</code> will get the <code>set_STR_4</code> method which accepts the same types as defined in the contract code. Below is an example where we chain several <code>set</code> methods and deploy the contract with the new constants.</p>
<pre><code class="language-rust ignore">    abigen!(Contract(
        name = &quot;MyContract&quot;,
        abi = &quot;packages/fuels/tests/contracts/configurables/out/debug/configurables-abi.json&quot;
    ));

    let wallet = launch_provider_and_get_wallet().await;

    let new_str: SizedAsciiString&lt;4&gt; = &quot;FUEL&quot;.try_into()?;
    let new_struct = StructWithGeneric {
        field_1: 16u8,
        field_2: 32,
    };
    let new_enum = EnumWithGeneric::VariantTwo;

    let configurables = MyContractConfigurables::new()
        .set_STR_4(new_str.clone())
        .set_STRUCT(new_struct.clone())
        .set_ENUM(new_enum.clone());

    let contract_id = Contract::load_from(
        &quot;tests/contracts/configurables/out/debug/configurables.bin&quot;,
        LoadConfiguration::default().set_configurables(configurables),
    )?
    .deploy(&amp;wallet, TxParameters::default())
    .await?;

    let contract_instance = MyContract::new(contract_id, wallet.clone());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-contracts"><a class="header" href="#interacting-with-contracts">Interacting with contracts</a></h1>
<p>If you already have a deployed contract and want to call its methods using the SDK,  but without deploying it again, all you need is the contract ID of your deployed contract. You can skip the whole deployment setup and call <code>::new(contract_id, wallet)</code> directly. For example:</p>
<pre><code class="language-rust ignore">            abigen!(Contract(
                name = &quot;MyContract&quot;,
                // Replace with your contract ABI.json path
                abi =
                    &quot;packages/fuels/tests/contracts/contract_test/out/debug/contract_test-abi.json&quot;
            ));
            let wallet_original = launch_provider_and_get_wallet().await;

            let wallet = wallet_original.clone();
            // Your bech32m encoded contract ID.
            let contract_id: Bech32ContractId =
                &quot;fuel1vkm285ypjesypw7vhdlhnty3kjxxx4efckdycqh3ttna4xvmxtfs6murwy&quot;
                    .parse()
                    .expect(&quot;Invalid ID&quot;);

            let connected_contract_instance = MyContract::new(contract_id, wallet);
            // You can now use the `connected_contract_instance` just as you did above!
</code></pre>
<p>The above example assumes that your contract id string is encoded in the bech32m format. You can recognize it by the human-readable-part &quot;fuel&quot; followed by the separator &quot;1&quot;. However, when using other Fuel tools, you might end up with a hex-encoded contract id string. In that case, you can create your contract instance as follows:</p>
<pre><code class="language-rust ignore">            let contract_id: ContractId =
                &quot;0x65b6a3d081966040bbccbb7f79ac91b48c635729c59a4c02f15ae7da999b32d3&quot;
                    .parse()
                    .expect(&quot;Invalid ID&quot;);
            let connected_contract_instance = MyContract::new(contract_id.into(), wallet);
</code></pre>
<p>You can learn more about the Fuel SDK bech32 types <a href="contracts/../types/bech32.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-fuelvm-binary-file"><a class="header" href="#the-fuelvm-binary-file">The FuelVM binary file</a></h1>
<p>The command <code>forc build</code> compiles your Sway code and generates the bytecode: the binary code that the Fuel Virtual Machine will interpret. For instance, the smart contract below:</p>
<pre><code class="language-Rust">contract;

abi MyContract {
    fn test_function() -&gt; bool;
}

impl MyContract for Contract {
    fn test_function() -&gt; bool {
        true
    }
}
</code></pre>
<p>After <code>forc build</code>, will have a binary file that contains:</p>
<pre><code class="language-terminal">$ cat out/debug/my-test.bin
G4]�]D`I]C�As@
           6]C�$@!QK%
</code></pre>
<p>This seems very unreadable! But, <code>forc</code> has a nice interpreter for this bytecode: <code>forc </code>parse-bytecode`, which will interpret that binary data and output the equivalent FuelVM assembly:</p>
<pre><code class="language-terminal">$ forc parse-bytecode out/debug/my-test.bin
half-word   byte   op                raw           notes
        0   0      JI(4)             90 00 00 04   jump to byte 16
        1   4      NOOP              47 00 00 00
        2   8      Undefined         00 00 00 00   data section offset lo (0)
        3   12     Undefined         00 00 00 34   data section offset hi (52)
        4   16     LW(63, 12, 1)     5d fc c0 01
        5   20     ADD(63, 63, 12)   10 ff f3 00
        6   24     LW(17, 6, 73)     5d 44 60 49
        7   28     LW(16, 63, 1)     5d 43 f0 01
        8   32     EQ(16, 17, 16)    13 41 14 00
        9   36     JNZI(16, 11)      73 40 00 0b   conditionally jump to byte 44
       10   40     RVRT(0)           36 00 00 00
       11   44     LW(16, 63, 0)     5d 43 f0 00
       12   48     RET(16)           24 40 00 00
       13   52     Undefined         00 00 00 00
       14   56     Undefined         00 00 00 01
       15   60     Undefined         00 00 00 00
       16   64     XOR(20, 27, 53)   21 51 bd 4b
</code></pre>
<p>If you want to deploy your smart contract using the SDK, this binary file is important; it's what we'll be sending to the FuelVM in a transaction.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-contracts"><a class="header" href="#calling-contracts">Calling contracts</a></h1>
<p>Once you've deployed your contract, as seen in the previous sections, you'll likely want to:</p>
<ol>
<li>Call contract methods;</li>
<li>Configure call and transaction parameters such as gas price, byte price, and gas limit;</li>
<li>Forward coins and gas in your contract calls;</li>
<li>Read and interpret returned values and logs.</li>
</ol>
<p>Here's an example. Suppose your Sway contract has two ABI methods called <code>initialize_counter(u64)</code> and <code>increment_counter(u64)</code>. Once you've deployed it the contract, you can call these methods like this:</p>
<pre><code class="language-rust ignore">        // This will generate your contract's methods onto `MyContract`.
        // This means an instance of `MyContract` will have access to all
        // your contract's methods that are running on-chain!
        abigen!(Contract(
            name = &quot;MyContract&quot;,
            abi = &quot;packages/fuels/tests/contracts/contract_test/out/debug/contract_test-abi.json&quot;
        ));

        // This is an instance of your contract which you can use to make calls to your functions
        let contract_instance = MyContract::new(contract_id_2, wallet);

        let response = contract_instance
            .methods()
            .initialize_counter(42) // Build the ABI call
            .call() // Perform the network call
            .await?;

        assert_eq!(42, response.value);

        let response = contract_instance
            .methods()
            .increment_counter(10)
            .call()
            .await?;

        assert_eq!(52, response.value);
</code></pre>
<p>The example above uses all the default configurations and performs a simple contract call.</p>
<p>Next, we'll see how we can further configure the many different parameters in a contract call</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calls-with-different-wallets"><a class="header" href="#calls-with-different-wallets">Calls with different wallets</a></h1>
<p>You can use the <code>with_wallet()</code> method on an existing contract instance as a shorthand for creating a new instance connected to the provided wallet. This lets you make contracts calls with different wallets in a chain like fashion.</p>
<pre><code class="language-rust ignore">        // Create contract instance with wallet_1
        let contract_instance = MyContract::new(contract_id, wallet_1.clone());

        // Perform contract call with wallet_2
        let response = contract_instance
            .with_account(wallet_2)? // Connect wallet_2
            .methods() // Get contract methods
            .get_msg_amount() // Our contract method
            .call() // Perform the contract call.
            .await?; // This is an async call, `.await` for it.
</code></pre>
<blockquote>
<p><strong>Note:</strong> connecting a different wallet to an existing instance ignores its set provider in favor of the provider used to deploy the contract. If you have two wallets connected to separate providers (each communicating with a separate fuel-core), the one assigned to the deploying wallet will also be used for contract calls. This behavior is only relevant if multiple providers (i.e. fuel-core instances) are present and can otherwise be ignored.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-parameters"><a class="header" href="#transaction-parameters">Transaction parameters</a></h1>
<p>Transaction parameters are:</p>
<ol>
<li>Gas price;</li>
<li>Gas limit;</li>
<li>Maturity.</li>
</ol>
<p>You can configure these parameters by creating an instance of <code>TxParameters</code> and passing it to a chain method called <code>tx_params</code>:</p>
<pre><code class="language-rust ignore">        let contract_methods = MyContract::new(contract_id.clone(), wallet.clone()).methods();

        let my_tx_parameters = TxParameters::default()
            .set_gas_price(1)
            .set_gas_limit(1_000_000)
            .set_maturity(0);

        let response = contract_methods
            .initialize_counter(42) // Our contract method.
            .tx_params(my_tx_parameters) // Chain the tx params setting method.
            .call() // Perform the contract call.
            .await?; // This is an async call, `.await` for it.
</code></pre>
<p>You can also use <code>TxParameters::default()</code> to use the default values:</p>
<pre><code class="language-rust ignore">pub const DEFAULT_GAS_PRICE: u64 = 0;
pub const DEFAULT_GAS_LIMIT: u64 = 1_000_000;
pub const DEFAULT_MATURITY: u64 = 0;
</code></pre>
<p>This way:</p>
<pre><code class="language-rust ignore">        let response = contract_methods
            .initialize_counter(42)
            .tx_params(TxParameters::default())
            .call()
            .await?;

</code></pre>
<p>As you might have noticed already, <code>TxParameters</code> can also be specified when deploying contracts or transfering assets by passing it to the respective methods.</p>
<blockquote>
<p><strong>Note:</strong> whenever you perform an action that results in a transaction (contract deployment, contract call, asset transfer), the SDK will automatically estimate the fee based on the set gas limit and the transaction's byte size. This estimation is used when building the transaction. A side-effect of this is that your wallet must at least own a single coin of the base asset of any amount.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-parameters"><a class="header" href="#call-parameters">Call parameters</a></h1>
<p>Call parameters are:</p>
<ol>
<li>Amount;</li>
<li>Asset ID;</li>
<li>Gas forwarded.</li>
</ol>
<p>You can use these to forward coins to a contract. You can configure these parameters by creating an instance of <a href="https://docs.rs/fuels/latest/fuels/core/parameters/struct.CallParameters.html#"><code>CallParameters</code></a> and passing it to a chain method called <code>call_params</code>.</p>
<p>For instance, suppose the following contract that uses Sway's <code>msg_amount()</code> to return the amount sent in that transaction.</p>
<pre><code class="language-rust ignore">    #[payable]
    fn get_msg_amount() -&gt; u64 {
        msg_amount()
    }
</code></pre>
<p>Then, in Rust, after setting up and deploying the above contract, you can configure the amount being sent in the transaction like this:</p>
<pre><code class="language-rust ignore">        let contract_methods = MyContract::new(contract_id, wallet.clone()).methods();

        let tx_params = TxParameters::default();

        // Forward 1_000_000 coin amount of base asset_id
        // this is a big number for checking that amount can be a u64
        let call_params = CallParameters::default().set_amount(1_000_000);

        let response = contract_methods
            .get_msg_amount() // Our contract method.
            .tx_params(tx_params) // Chain the tx params setting method.
            .call_params(call_params)? // Chain the call params setting method.
            .call() // Perform the contract call.
            .await?;
</code></pre>
<p><code>call_params</code> returns a result to ensure you don't forward assets to a contract method that isn't payable. In the following example, we try to forward an amount of 100 of the base asset to <code>non_payable</code>. As its name suggests, <code>non_payable</code> isn't annotated with <code>#[payable]</code> in the contract code. Passing <code>CallParameters</code> with an amount other than 0 leads to an <code>InvalidCallParameters</code> error:</p>
<pre><code class="language-rust ignore">    let err = contract_methods
        .non_payable()
        .call_params(CallParameters::default().set_amount(100))
        .expect_err(&quot;Should return call params error.&quot;);

    assert!(matches!(err, Error::AssetsForwardedToNonPayableMethod));
</code></pre>
<blockquote>
<p><strong>Note:</strong> forwarding gas to a contract call is always possible, regardless of the contract method being non-payable.</p>
</blockquote>
<p>You can also use <code>CallParameters::default()</code> to use the default values:</p>
<pre><code class="language-rust ignore">pub const DEFAULT_CALL_PARAMS_AMOUNT: u64 = 0;
// Bytes representation of the asset ID of the &quot;base&quot; asset used for gas fees.
pub const BASE_ASSET_ID: AssetId = AssetId::BASE;
</code></pre>
<p>This way:</p>
<pre><code class="language-rust ignore">        let response = contract_methods
            .initialize_counter(42)
            .call_params(CallParameters::default())?
            .call()
            .await?;
</code></pre>
<p>The <code>gas_forwarded</code> parameter defines the limit for the actual contract call as opposed to the gas limit for the whole transaction. This means that it is constrained by the transaction limit. If it is set to an amount greater than the available gas, all available gas will be forwarded.</p>
<pre><code class="language-rust ignore">        // Set the transaction `gas_limit` to 10_000 and `gas_forwarded` to 4300 to specify that
        // the contract call transaction may consume up to 10_000 gas, while the actual call may
        // only use 4300 gas
        let tx_params = TxParameters::default().set_gas_limit(10_000);
        let call_params = CallParameters::default().set_gas_forwarded(4300);

        let response = contract_methods
            .get_msg_amount() // Our contract method.
            .tx_params(tx_params) // Chain the tx params setting method.
            .call_params(call_params)? // Chain the call params setting method.
            .call() // Perform the contract call.
            .await?;
</code></pre>
<p>If you don't set the call parameters or use <code>CallParameters::default()</code>, the transaction gas limit will be forwarded instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-asset-transfer"><a class="header" href="#custom-asset-transfer">Custom asset transfer</a></h1>
<p>The SDK provides the option to transfer assets within the same transaction, when making a contract call. By using <code>add_custom_asset()</code> you specify the asset id, the amount, and the destination address:</p>
<pre><code class="language-rust ignore">        let amount = 1000;
        let _ = contract_instance
            .methods()
            .initialize_counter(42)
            .add_custom_asset(BASE_ASSET_ID, amount, Some(other_wallet.address().clone()))
            .call()
            .await?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-response"><a class="header" href="#call-response">Call response</a></h1>
<p>You've probably noticed that you're often chaining <code>.call().await.unwrap()</code>. That's because:</p>
<ol>
<li>You have to choose between <code>.call()</code> and <code>.simulate()</code> (more on this in the next section);</li>
<li>Contract calls are asynchronous, so you can choose to either <code>.await</code> it or perform concurrent tasks, making full use of Rust's async;</li>
<li><code>.unwrap()</code> the <code>Result&lt;FuelCallResponse, Error&gt;</code> returned by the contract call.</li>
</ol>
<p>Once you unwrap the <code>FuelCallResponse</code>, you have access to this struct:</p>
<pre><code class="language-rust ignore">pub struct FuelCallResponse&lt;D&gt; {
    pub value: D,
    pub receipts: Vec&lt;Receipt&gt;,
    pub gas_used: u64,
    pub log_decoder: LogDecoder,
}
</code></pre>
<p>Where <code>value</code> will hold the value returned by its respective contract method, represented by the exact type returned by the FuelVM, E.g., if your contract returns a FuelVM's <code>u64</code>, <code>value</code>'s <code>D</code> will be a <code>u64</code>. If it's a FuelVM's tuple <code>(u8,bool)</code>, then <code>D</code> will be a <code>(u8,bool)</code>. If it's a custom type, for instance, a Sway struct <code>MyStruct</code> containing two components, a <code>u64</code>, and a <code>b256</code>, <code>D</code> will be a struct generated at compile-time, called <code>MyStruct</code> with <code>u64</code> and a <code>[u8; 32]</code> (the equivalent of <code>b256</code> in Rust-land).</p>
<ul>
<li><code>receipts</code> will hold all <a href="https://specs.fuel.network/master/protocol/abi/receipts.html">receipts</a> generated by that specific contract call.</li>
<li><code>gas_used</code> is the amount of gas it consumed by the contract call.</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h2>
<p>You can use the <code>is_ok</code> and <code>is_err</code> methods to check if a contract call <code>Result</code> is ok or contains an error. These methods will return either <code>true</code> or <code>false</code>.</p>
<pre><code class="language-rust  ignore">let is_ok = response.is_ok();
let is_error = response.is_err();
</code></pre>
<p>If <code>is_err</code> returns <code>true</code>, you can use the <code>unwrap_err</code> method to unwrap the error message.</p>
<pre><code class="language-rust  ignore">if response.is_err() {
    let err = response.unwrap_err();
    println!(&quot;ERROR: {:?}&quot;, err);
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logs"><a class="header" href="#logs">Logs</a></h1>
<p>Whenever you log a value within a contract method, the resulting log entry is added to the log receipt and the variable type is recorded in the contract's ABI. The SDK lets you parse those values into Rust types.</p>
<p>Consider the following contract method:</p>
<pre><code class="language-rust ignore">    fn produce_logs_variables() {
        let f: u64 = 64;
        let u: b256 = 0xef86afa9696cf0dc6385e2c407a6e159a1103cefb7e2ae0636fb33d3cb2a9e4a;
        let e: str[4] = &quot;Fuel&quot;;
        let l: [u8; 3] = [1u8, 2u8, 3u8];

        log(f);
        log(u);
        log(e);
        log(l);
    }
</code></pre>
<p>You can access the logged values in Rust by calling <code>decode_logs_with_type::&lt;T&gt;</code> from a <code>FuelCallResponse</code>, where <code>T</code> is the type of the logged variables you want to retrieve. The result will be a <code>Vec&lt;T&gt;</code>:</p>
<pre><code class="language-rust ignore">    let contract_methods = contract_instance.methods();
    let response = contract_methods.produce_logs_variables().call().await?;

    let log_u64 = response.decode_logs_with_type::&lt;u64&gt;()?;
    let log_bits256 = response.decode_logs_with_type::&lt;Bits256&gt;()?;
    let log_string = response.decode_logs_with_type::&lt;SizedAsciiString&lt;4&gt;&gt;()?;
    let log_array = response.decode_logs_with_type::&lt;[u8; 3]&gt;()?;

    let expected_bits256 = Bits256([
        239, 134, 175, 169, 105, 108, 240, 220, 99, 133, 226, 196, 7, 166, 225, 89, 161, 16, 60,
        239, 183, 226, 174, 6, 54, 251, 51, 211, 203, 42, 158, 74,
    ]);

    assert_eq!(log_u64, vec![64]);
    assert_eq!(log_bits256, vec![expected_bits256]);
    assert_eq!(log_string, vec![&quot;Fuel&quot;]);
    assert_eq!(log_array, vec![[1, 2, 3]]);
</code></pre>
<p>You can use the <code>decode_logs()</code> function to retrieve a <code>LogResult</code> struct containing a <code>results</code> field that is a vector of <code>Result&lt;String&gt;</code> values representing the success or failure of decoding each log.</p>
<pre><code class="language-rust  ignore">    let contract_methods = contract_instance.methods();
    let response = contract_methods.produce_multiple_logs().call().await?;
    let logs = response.decode_logs();
</code></pre>
<p>Due to possible performance hits, it is not recommended to use <code>decode_logs()</code> outside of a debugging scenario.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output-variables"><a class="header" href="#output-variables">Output variables</a></h1>
<p>Sometimes, the contract you call might transfer funds to a specific address, depending on its execution. The underlying transaction for such a contract call has to have the appropriate number of <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/output.md#outputvariable">variable outputs</a> to succeed.</p>
<p>Let's say you deployed a contract with the following method:</p>
<pre><code class="language-rust ignore">    fn transfer_coins_to_output(coins: u64, asset_id: ContractId, recipient: Address) {
        transfer_to_address(coins, asset_id, recipient);
    }
</code></pre>
<p>When calling <code>transfer_coins_to_output</code> with the SDK, you can specify the number of variable outputs by chaining <code>append_variable_outputs(amount)</code> to your call. Like this:</p>
<pre><code class="language-rust ignore">        let address = wallet.address();

        // withdraw some tokens to wallet
        let response = contract_methods
            .transfer_coins_to_output(1_000_000, contract_id.into(), address.into())
            .append_variable_outputs(1)
            .call()
            .await?;
</code></pre>
<p><code>append_variable_outputs</code> effectively appends a given amount of <code>Output::Variable</code>s to the transaction's list of outputs. This output type indicates that the amount and the owner may vary based on transaction execution.</p>
<blockquote>
<p><strong>Note:</strong> that the Sway <code>lib-std</code> function <code>mint_to_address</code> calls <code>transfer_to_address</code> under the hood, so you need to call <code>append_variable_outputs</code> in the Rust SDK tests like you would for <code>transfer_to_address</code>.</p>
</blockquote>
<h1 id="output-messages"><a class="header" href="#output-messages">Output messages</a></h1>
<p>Similarly, when your contract transfers messages, the underlying transaction has to have the appropriate number of <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/output.md#outputmessage">output messages</a>. </p>
<p>Output messages can be added to a contract call by chaining <code>append_output_messages(amount)</code>:</p>
<pre><code class="language-rust ignore">        let base_layer_address = Bits256([1u8; 32]);
        let amount = 1000;

        let response = contract_methods
            .send_message(base_layer_address, amount)
            .append_message_outputs(1)
            .call()
            .await?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-only-calls"><a class="header" href="#read-only-calls">Read-only calls</a></h1>
<p>Sometimes you want to call a contract method that doesn't change the state of the blockchain. For instance, a method that only reads a value from storage and returns it.</p>
<p>In this case, there's no need to generate an actual blockchain transaction; you only want to read a value quickly.</p>
<p>You can do this with the SDK. Instead of <code>.call()</code>ing the method, use <code>.simulate()</code>:</p>
<pre><code class="language-rust ignore">        // you would mint 100 coins if the transaction wasn't simulated
        let counter = contract_methods.mint_coins(100).simulate().await?;
</code></pre>
<p>Note that if you use <code>.simulate()</code> on a method that <em>does</em> change the state of the blockchain, it won't work properly; it will just <code>dry-run</code> it.</p>
<p>At the moment, it's up to you to know whether a contract method changes state or not, and use <code>.call()</code> or <code>.simulate()</code> accordingly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-other-contracts"><a class="header" href="#calling-other-contracts">Calling other contracts</a></h1>
<p>If your contract method is calling other contracts you will have to add the appropriate <code>Inputs</code> and <code>Outputs</code> to your transaction. For your convenience, the <code>ContractCallHandler</code> provides methods that prepare those inputs and outpus for you. You have two methods that you can use: <code>set_contracts(&amp;[&amp;contract_instance, ...])</code> and <code>set_contract_ids(&amp;[&amp;contract_id, ...])</code>.</p>
<p><code>set_contracts(&amp;[&amp;contract_instance, ...])</code> requires contract instances that were created using the <code>abigen</code> macro. When setting the external contracts with this method, logs and require revert errors originating from the external contract can be propagated and decoded by the calling contract.</p>
<pre><code class="language-rust ignore">    let response = contract_caller_instance
        .methods()
        .increment_from_contract(lib_contract_id.into(), 42)
        .set_contracts(&amp;[&amp;lib_contract_instance])
        .call()
        .await?;
</code></pre>
<p>If however, you do not need do decode logs or you do not have a contract instance that was generated using the <code>abigen</code> macro you can use <code>set_contract_ids(&amp;[&amp;contract_id, ...])</code> and provide the required contract ids.</p>
<pre><code class="language-rust ignore">    let response = contract_caller_instance
        .methods()
        .increment_from_contract(lib_contract_id.into(), 42)
        .set_contract_ids(&amp;[lib_contract_id.clone()])
        .call()
        .await?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-contract-calls"><a class="header" href="#multiple-contract-calls">Multiple contract calls</a></h1>
<p>With <code>ContractMultiCallHandler</code>, you can execute multiple contract calls within a single transaction. To achieve this, you first prepare all the contract calls that you want to bundle:</p>
<pre><code class="language-rust ignore">        let contract_methods = MyContract::new(contract_id, wallet.clone()).methods();

        let call_handler_1 = contract_methods.initialize_counter(42);
        let call_handler_2 = contract_methods.get_array([42; 2]);
</code></pre>
<p>You can also set call parameters, variable outputs, or external contracts for every contract call, as long as you don't execute it with <code>call()</code> or <code>simulate()</code>.</p>
<p>Next, you provide the prepared calls to your <code>ContractMultiCallHandler</code> and optionally configure transaction parameters:</p>
<pre><code class="language-rust ignore">        let mut multi_call_handler = MultiContractCallHandler::new(wallet.clone());

        multi_call_handler
            .add_call(call_handler_1)
            .add_call(call_handler_2);
</code></pre>
<blockquote>
<p><strong>Note:</strong> any transaction parameters configured on separate contract calls are disregarded in favor of the parameters provided to <code>ContractMultiCallHandler</code>.</p>
</blockquote>
<h2 id="output-values"><a class="header" href="#output-values">Output values</a></h2>
<p>To get the output values of the bundled calls, you need to provide explicit type annotations when saving the result of <code>call()</code> or <code>simulate()</code> to a variable:</p>
<pre><code class="language-rust ignore">        let (counter, array): (u64, [u64; 2]) = multi_call_handler.call().await?.value;
</code></pre>
<p>You can also interact with the <code>FuelCallResponse</code> by moving the type annotation to the invoked method:</p>
<pre><code class="language-rust ignore">        let response = multi_call_handler.call::&lt;(u64, [u64; 2])&gt;().await?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-dependency-estimation"><a class="header" href="#transaction-dependency-estimation">Transaction dependency estimation</a></h1>
<p>Previously, we mentioned that a contract call might require you to manually specify external contracts, variable outputs, or output messages. The SDK can also attempt to estimate and set these dependencies for you at the cost of running multiple simulated calls in the background.</p>
<p>The following example uses a contract call that calls an external contract and later mints assets to a specified address. Calling it without including the dependencies will result in a revert:</p>
<pre><code class="language-rust ignore">        let address = wallet.address();
        let amount = 100;

        let response = contract_methods
            .increment_from_contract_then_mint(called_contract_id, amount, address.into())
            .call()
            .await;

        assert!(matches!(
            response,
            Err(Error::RevertTransactionError { .. })
        ));
</code></pre>
<p>As mentioned in previous chapters, you can specify the external contract with <code>.set_contracts()</code> and add an output variable with <code>append_variable_outputs()</code> to resolve this:</p>
<pre><code class="language-rust ignore">        let response = contract_methods
            .increment_from_contract_then_mint(called_contract_id, amount, address.into())
            .append_variable_outputs(1)
            .set_contract_ids(&amp;[called_contract_id.into()])
            .call()
            .await?;
</code></pre>
<p>But this requires you to know the contract id of the external contract and the needed number of output variables. Alternatively, by chaining <code>.estimate_tx_dependencies()</code> instead, the dependencies will be estimated by the SDK and set automatically. The optional parameter is the maximum number of simulation attempts:</p>
<pre><code class="language-rust ignore">        let response = contract_methods
            .increment_from_contract_then_mint(called_contract_id, amount, address.into())
            .estimate_tx_dependencies(Some(2))
            .await?
            .call()
            .await?;
</code></pre>
<p>The minimal number of attempts corresponds to the number of external contracts and output variables needed and defaults to 10.</p>
<blockquote>
<p><strong>Note:</strong> <code>estimate_tx_dependencies()</code> can also be used when working with multi calls.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> <code>estimate_tx_dependencies()</code> does not currently resolve the dependencies needed for logging from an external contract. For more information, see <a href="calling-contracts/./calling-contracts/logs.html">here</a>.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> if no resolution was found after exhausting all simulation attempts, the last received error will be propagated. The same will happen if an error is unrelated to transaction dependencies.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estimating-contract-call-cost"><a class="header" href="#estimating-contract-call-cost">Estimating contract call cost</a></h1>
<p>With the function <code>estimate_transaction_cost(tolerance: Option&lt;f64&gt;)</code> provided by <code>ContractCallHandler</code> and <code>ContractMultiCallHandler</code>, you can get a cost estimation for a specific call. The return type, <code>TransactionCost</code>, is a struct that contains relevant information for the estimation:</p>
<pre><code class="language-rust ignore">TransactionCost {
    min_gas_price: u64,
    min_byte_price: u64,
    gas_price: u64,
    gas_used: u64,
    metered_bytes_size: u64,
    total_fee: f64, // where total_fee is the sum of the gas and byte fees
}
</code></pre>
<p>Below are examples that show how to get the estimated transaction cost from single and multi call transactions.</p>
<pre><code class="language-rust ignore">        let contract_instance = MyContract::new(contract_id, wallet);

        let tolerance = 0.0;
        let transaction_cost = contract_instance
            .methods()
            .initialize_counter(42) // Build the ABI call
            .estimate_transaction_cost(Some(tolerance)) // Get estimated transaction cost
            .await?;
</code></pre>
<pre><code class="language-rust ignore">        let mut multi_call_handler = MultiContractCallHandler::new(wallet.clone());

        let call_handler_1 = contract_methods.initialize_counter(42);
        let call_handler_2 = contract_methods.get_array([42; 2]);

        multi_call_handler
            .add_call(call_handler_1)
            .add_call(call_handler_2);

        let tolerance = 0.0;
        let transaction_cost = multi_call_handler
            .estimate_transaction_cost(Some(tolerance)) // Get estimated transaction cost
            .await?;
</code></pre>
<p>The transaction cost estimation can be used to set the gas limit for an actual call, or to show the user the estimated cost.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-scripts"><a class="header" href="#running-scripts">Running scripts</a></h1>
<p>You can run a script using its JSON-ABI and the path to its binary file. You can run the scripts with arguments. For this, you have to use the <code>abigen!</code> macro seen <a href="getting-started/../abigen/the-abigen-macro.html">previously</a>.</p>
<pre><code class="language-rust ignore">    // The abigen is used for the same purpose as with contracts (Rust bindings)
    abigen!(Script(
        name = &quot;MyScript&quot;,
        abi = &quot;packages/fuels/tests/scripts/arguments/out/debug/arguments-abi.json&quot;
    ));
    let wallet = launch_provider_and_get_wallet().await;
    let bin_path = &quot;../fuels/tests/scripts/arguments/out/debug/arguments.bin&quot;;
    let instance = MyScript::new(wallet, bin_path);

    let bim = Bimbam { val: 90 };
    let bam = SugarySnack {
        twix: 100,
        mars: 1000,
    };
    let result = instance.main(bim, bam).call().await?;
    let expected = Bimbam { val: 2190 };
    assert_eq!(result.value, expected);
</code></pre>
<h2 id="running-scripts-with-transaction-parameters"><a class="header" href="#running-scripts-with-transaction-parameters">Running scripts with transaction parameters</a></h2>
<p>The method for passing transaction parameters is the same as <a href="getting-started/../calling-contracts/tx-params.html">with contracts</a>. As a reminder, the workflow would look like this:</p>
<pre><code class="language-rust ignore">    let parameters = TxParameters::default()
        .set_gas_price(1)
        .set_gas_limit(10_000);
    let result = instance.main(a, b).tx_params(parameters).call().await?;
</code></pre>
<h2 id="logs-1"><a class="header" href="#logs-1">Logs</a></h2>
<p>Script calls provide the same logging functions, <code>decode_logs()</code> and <code>decode_logs_with_type&lt;T&gt;()</code>, as contract calls. As a reminder, the workflow looks like this:</p>
<pre><code class="language-rust ignore">    abigen!(Script(
        name = &quot;log_script&quot;,
        abi = &quot;packages/fuels/tests/logs/script_logs/out/debug/script_logs-abi.json&quot;
    ));

    let wallet = launch_provider_and_get_wallet().await;
    let bin_path = &quot;../fuels/tests/logs/script_logs/out/debug/script_logs.bin&quot;;
    let instance = log_script::new(wallet.clone(), bin_path);

    let response = instance.main().call().await?;

    let logs = response.decode_logs();
    let log_u64 = response.decode_logs_with_type::&lt;u64&gt;()?;
</code></pre>
<h2 id="calling-contracts-from-scripts"><a class="header" href="#calling-contracts-from-scripts">Calling contracts from scripts</a></h2>
<p>Scripts use the same interfaces for setting external contracts as <a href="getting-started/../calling-contracts/other-contracts.html">contract methods</a>.</p>
<p>Below is an example that uses <code>set_contracts(&amp;[&amp;contract_instance, ...])</code>.</p>
<pre><code class="language-rust ignore">    let response = instance
        .main(contract_id)
        .set_contracts(&amp;[&amp;contract_instance])
        .call()
        .await?;
</code></pre>
<p>And this is an example that uses <code>set_contract_ids(&amp;[&amp;contract_id, ...])</code>.</p>
<pre><code class="language-rust ignore">    let response = instance
        .main(contract_id)
        .set_contract_ids(&amp;[contract_id.into()])
        .call()
        .await?;
</code></pre>
<h1 id="configurable-constants-1"><a class="header" href="#configurable-constants-1">Configurable constants</a></h1>
<p>Same as contracts, you can define <code>configurable</code> constants in <code>scripts</code> which can be changed during the script execution. Here is an example how the constants are defined.</p>
<pre><code class="language-rust ignore">script;

enum EnumWithGeneric&lt;D&gt; {
    VariantOne: D,
    VariantTwo: (),
}

struct StructWithGeneric&lt;D&gt; {
    field_1: D,
    field_2: u64,
}

configurable {
    U8: u8 = 8u8,
    BOOL: bool = true,
    ARRAY: [u32; 3] = [253u32, 254u32, 255u32],
    STR_4: str[4] = &quot;fuel&quot;,
    STRUCT: StructWithGeneric&lt;u8&gt; = StructWithGeneric {
        field_1: 8u8,
        field_2: 16,
    },
    ENUM: EnumWithGeneric&lt;bool&gt; = EnumWithGeneric::VariantOne(true),
}

fn main() -&gt; (u8, bool, [u32; 3], str[4], StructWithGeneric&lt;u8&gt;, EnumWithGeneric&lt;bool&gt;) {
    (U8, BOOL, ARRAY, STR_4, STRUCT, ENUM)
}
</code></pre>
<p>Each of the configurable constants will get a dedicated <code>set</code> method in the SDK. For example, the constant <code>STR_4</code> will get the <code>set_str_4</code> method which accepts the same types as defined in sway. Below is an example where we chain several <code>set</code> methods and execute the script with the new constants.</p>
<pre><code class="language-rust ignore">    abigen!(Script(name=&quot;MyScript&quot;, abi=&quot;packages/fuels/tests/scripts/script_configurables/out/debug/script_configurables-abi.json&quot;));

    let wallet = launch_provider_and_get_wallet().await;
    let bin_path = &quot;../fuels/tests/scripts/script_configurables/out/debug/script_configurables.bin&quot;;
    let instance = MyScript::new(wallet, bin_path);

    let new_str: SizedAsciiString&lt;4&gt; = &quot;FUEL&quot;.try_into()?;
    let new_struct = StructWithGeneric {
        field_1: 16u8,
        field_2: 32,
    };
    let new_enum = EnumWithGeneric::VariantTwo;

    let configurables = MyScriptConfigurables::new()
        .set_STR_4(new_str.clone())
        .set_STRUCT(new_struct.clone())
        .set_ENUM(new_enum.clone());

    let response = instance
        .with_configurables(configurables)
        .main()
        .call()
        .await?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicates"><a class="header" href="#predicates">Predicates</a></h1>
<p>Predicates, in Sway, are programs that return a Boolean value and do not have any side effects (they are pure). A predicate address can own assets. The predicate address is generated from the compiled byte code and is the same as the <code>P2SH</code> address used in Bitcoin. Users can seamlessly send assets to the predicate address as they do for any other address. To spend the predicate funds, the user has to provide the original <code>byte code</code> of the predicate together with the <code>predicate data</code>. The <code>predicate data</code> will be used when executing the <code>byte code</code>, and the funds can be transferred if the predicate is validated successfully.</p>
<h2 id="instantiating-predicates"><a class="header" href="#instantiating-predicates">Instantiating predicates</a></h2>
<p>Let's consider the following predicate example:</p>
<pre><code class="language-rust ignore">predicate;

fn main(a: u32, b: u64) -&gt; bool {
    a == b
}
</code></pre>
<p>We will look at a complete example of using the SDK to send and receive funds from a predicate.</p>
<p>First, we set up the wallets, node, and a predicate encoder instance. The call to the <code>abigen!</code> macro will generate all the types specified in the predicate plus a custom encoder with an <code>encode_data</code> function that will conveniently encode all the arguments of the main function for us.</p>
<pre><code class="language-rust ignore">        let asset_id = AssetId::default();
        let wallets_config = WalletsConfig::new_multiple_assets(
            2,
            vec![AssetConfig {
                id: asset_id,
                num_coins: 1,
                coin_amount: 1_000,
            }],
        );

        let wallets = &amp;launch_custom_provider_and_get_wallets(wallets_config, None, None).await;

        let first_wallet = &amp;wallets[0];
        let second_wallet = &amp;wallets[1];

        abigen!(Predicate(name=&quot;MyPredicateEncoder&quot;, abi=&quot;packages/fuels/tests/predicates/basic_predicate/out/debug/basic_predicate-abi.json&quot;));

Once we've compiled our predicate with `forc build`, we can create a `Predicate` instance via `Predicate::load_from`. The resulting data from `encode_data` can then be set on the loaded predicate.

```rust,ignore
        let predicate_data = MyPredicateEncoder::encode_data(4096, 4096);
        let code_path =
            &quot;../../packages/fuels/tests/predicates/basic_predicate/out/debug/basic_predicate.bin&quot;;

        let predicate: Predicate = Predicate::load_from(code_path)?
            .with_data(predicate_data)
            .with_provider(first_wallet.try_provider()?.clone());
</code></pre>
<p>Next, we lock some assets in this predicate using the first wallet:</p>
<pre><code class="language-rust ignore">        // First wallet transfers amount to predicate.
        first_wallet
            .transfer(predicate.address(), 500, asset_id, TxParameters::default())
            .await?;

        // Check predicate balance.
        let balance = predicate.get_asset_balance(&amp;AssetId::default()).await?;

        assert_eq!(balance, 500);
</code></pre>
<p>Then we can transfer assets owned by the predicate via the <a href="getting-started/../getting-started/account.html">Account</a> trait:</p>
<pre><code class="language-rust ignore">        let amount_to_unlock = 500;

        predicate
            .transfer(
                second_wallet.address(),
                amount_to_unlock,
                asset_id,
                TxParameters::default(),
            )
            .await?;

        // Predicate balance is zero.
        let balance = predicate.get_asset_balance(&amp;AssetId::default()).await?;

        assert_eq!(balance, 0);

        // Second wallet balance is updated.
        let balance = second_wallet.get_asset_balance(&amp;AssetId::default()).await?;
        assert_eq!(balance, 1500);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signatures-in-predicates-example"><a class="header" href="#signatures-in-predicates-example">Signatures in predicates example</a></h1>
<p>This is a more involved example where the predicate accepts three signatures and matches them to three predefined public keys. The <code>ec_recover_address</code> function is used to recover the public key from the signatures. If two of the three extracted public keys match the predefined public keys, the funds can be spent. Note that the signature order has to match the order of the predefined public keys.</p>
<pre><code class="language-rust ignore">predicate;

use std::{b512::B512, constants::ZERO_B256, ecr::ec_recover_address, inputs::input_predicate_data};

fn extract_pulic_key_and_match(signature: B512, expected_public_key: b256) -&gt; u64 {
    if let Result::Ok(pub_key_sig) = ec_recover_address(signature, ZERO_B256)
    {
        if pub_key_sig.value == expected_public_key {
            return 1;
        }
    }
    0
}

fn main(signatures: [B512; 3]) -&gt; bool {
    let public_keys = [
        0xd58573593432a30a800f97ad32f877425c223a9e427ab557aab5d5bb89156db0,
        0x14df7c7e4e662db31fe2763b1734a3d680e7b743516319a49baaa22b2032a857,
        0x3ff494fb136978c3125844625dad6baf6e87cdb1328c8a51f35bda5afe72425c,
    ];

    let mut matched_keys = 0;

    matched_keys = extract_pulic_key_and_match(signatures[0], public_keys[0]);
    matched_keys = matched_keys + extract_pulic_key_and_match(signatures[1], public_keys[1]);
    matched_keys = matched_keys + extract_pulic_key_and_match(signatures[2], public_keys[2]);

    matched_keys &gt; 1
}
</code></pre>
<p>Let's use the SDK to interact with the predicate. First, let's create three wallets with specific keys. Their hashed public keys are already hard-coded in the predicate. Then we create the receiver wallet, which we will use to spend the predicate funds.</p>
<pre><code class="language-rust ignore">        let secret_key1: SecretKey =
            &quot;0x862512a2363db2b3a375c0d4bbbd27172180d89f23f2e259bac850ab02619301&quot;
                .parse()
                .unwrap();

        let secret_key2: SecretKey =
            &quot;0x37fa81c84ccd547c30c176b118d5cb892bdb113e8e80141f266519422ef9eefd&quot;
                .parse()
                .unwrap();

        let secret_key3: SecretKey =
            &quot;0x976e5c3fa620092c718d852ca703b6da9e3075b9f2ecb8ed42d9f746bf26aafb&quot;
                .parse()
                .unwrap();

        let mut wallet = WalletUnlocked::new_from_private_key(secret_key1, None);
        let mut wallet2 = WalletUnlocked::new_from_private_key(secret_key2, None);
        let mut wallet3 = WalletUnlocked::new_from_private_key(secret_key3, None);
        let mut receiver = WalletUnlocked::new_random(None);
</code></pre>
<p>Next, let's add some coins, start a provider and connect it with the wallets.</p>
<pre><code class="language-rust ignore">        let asset_id = AssetId::default();
        let num_coins = 32;
        let amount = 64;
        let initial_balance = amount * num_coins;
        let all_coins = [&amp;wallet, &amp;wallet2, &amp;wallet3, &amp;receiver]
            .iter()
            .flat_map(|wallet| {
                setup_single_asset_coins(wallet.address(), asset_id, num_coins, amount)
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();

        let (provider, _) = setup_test_provider(all_coins, vec![], None, None).await;

        [&amp;mut wallet, &amp;mut wallet2, &amp;mut wallet3, &amp;mut receiver]
            .iter_mut()
            .for_each(|wallet| {
                wallet.set_provider(provider.clone());
            });
</code></pre>
<p>Now we can use the predicate abigen to create a predicate encoder instance for us. To spend the funds now locked in the predicate, we must provide two out of three signatures whose public keys match the ones we defined in the predicate. In this example, the signatures are generated from an array of zeros.</p>
<pre><code class="language-rust ignore">        abigen!(Predicate(
            name = &quot;MyPredicateEncoder&quot;,
            abi = &quot;packages/fuels/tests/predicates/signatures/out/debug/signatures-abi.json&quot;
        ));

        let predicate_data = MyPredicateEncoder::encode_data(signatures);
        let code_path = &quot;../../packages/fuels/tests/predicates/signatures/out/debug/signatures.bin&quot;;

        let predicate: Predicate = Predicate::load_from(code_path)?
            .with_data(predicate_data)
            .with_provider(provider.clone());
</code></pre>
<p>Next, we transfer some assets from a wallet to the created predicate. We also confirm that the funds are indeed transferred.</p>
<pre><code class="language-rust ignore">        let amount_to_predicate = 512;

        wallet
            .transfer(
                predicate.address(),
                amount_to_predicate,
                asset_id,
                TxParameters::default(),
            )
            .await?;

        let predicate_balance = predicate.get_asset_balance(&amp;asset_id).await?;
        assert_eq!(predicate_balance, amount_to_predicate);
</code></pre>
<p>We can use the <code>transfer</code> method from the <a href="predicates/../getting-started/account.html">Account</a> trait to transfer the assets. If the predicate data is correct, the <code>receiver</code> wallet will get the funds, and we will verify that the amount is correct.</p>
<pre><code class="language-rust ignore">        predicate
            .transfer(
                receiver.address(),
                amount_to_predicate,
                asset_id,
                TxParameters::default(),
            )
            .await?;

        let receiver_balance_after = receiver.get_asset_balance(&amp;asset_id).await?;
        assert_eq!(
            initial_balance + amount_to_predicate,
            receiver_balance_after
        );

        let predicate_balance = predicate.get_asset_balance(&amp;asset_id).await?;
        assert_eq!(predicate_balance, 0);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>The FuelVM and Sway have many internal types. These types have equivalents in the SDK. This section discusses these types, how to use them, and how to convert them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes32"><a class="header" href="#bytes32">Bytes32</a></h1>
<p>In Sway and the FuelVM, <code>Bytes32</code> represents hashes. They hold a 256-bit (32-byte) value. <code>Bytes32</code> is a wrapper on a 32-sized slice of <code>u8</code>: <code>pub struct Bytes32([u8; 32]);</code>.</p>
<p>These are the main ways of creating a <code>Bytes32</code>:</p>
<pre><code class="language-rust ignore">        use std::str::FromStr;

        use fuels::tx::Bytes32;

        // Zeroed Bytes32
        let b256 = Bytes32::zeroed();

        // Grab the inner `[u8; 32]` from
        // `Bytes32` by dereferencing (i.e. `*`) it.
        assert_eq!([0u8; 32], *b256);

        // From a `[u8; 32]`.
        let my_slice = [1u8; 32];
        let b256 = Bytes32::new(my_slice);
        assert_eq!([1u8; 32], *b256);

        // From a hex string.
        let hex_str = &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;;
        let b256 = Bytes32::from_str(hex_str).expect(&quot;failed to create Bytes32 from string&quot;);
        assert_eq!([0u8; 32], *b256);
</code></pre>
<p><code>Bytes32</code> also implements <em>fmt's</em> <code>Debug</code>, <code>Display</code>, <code>LowerHex</code> and <code>UpperHex</code> traits. For example, you can get the display and hex representations with:</p>
<pre><code class="language-rust ignore">        let b256_string = b256.to_string();
        let b256_hex_string = format!(&quot;{b256:#x}&quot;);
</code></pre>
<p>For a full list of implemented methods and traits, see the <a href="https://docs.rs/fuel-types/latest/fuel_types/struct.Bytes32.html">fuel-types documentation</a>.</p>
<blockquote>
<p><strong>Note:</strong> In Fuel, there's a special type called <code>b256</code>, which is similar to <code>Bytes32</code>; also used to represent hashes, and it holds a 256-bit value. In Rust, through the SDK, this is represented as <code>Bits256(value)</code> where <code>value</code> is a <code>[u8; 32]</code>. If your contract method takes a <code>b256</code> as input, all you need to do is pass a <code>Bits256([u8; 32])</code> when calling it from the SDK.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address"><a class="header" href="#address">Address</a></h1>
<p>Like <code>Bytes32</code>, <code>Address</code> is a wrapper on <code>[u8; 32]</code> with similar methods and implements the same traits (see <a href="https://docs.rs/fuel-types/latest/fuel_types/struct.Address.html">fuel-types documentation</a>).</p>
<p>These are the main ways of creating an <code>Address</code>:</p>
<pre><code class="language-rust ignore">        use std::str::FromStr;

        use fuels::tx::Address;

        // Zeroed Bytes32
        let address = Address::zeroed();

        // Grab the inner `[u8; 32]` from
        // `Bytes32` by dereferencing (i.e. `*`) it.
        assert_eq!([0u8; 32], *address);

        // From a `[u8; 32]`.
        let my_slice = [1u8; 32];
        let address = Address::new(my_slice);
        assert_eq!([1u8; 32], *address);

        // From a string.
        let hex_str = &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;;
        let address = Address::from_str(hex_str).expect(&quot;failed to create Address from string&quot;);
        assert_eq!([0u8; 32], *address);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contractid"><a class="header" href="#contractid">ContractId</a></h1>
<p>Like <code>Bytes32</code>, <code>ContractId</code> is a wrapper on <code>[u8; 32]</code> with similar methods and implements the same traits (see <a href="https://docs.rs/fuel-types/latest/fuel_types/struct.ContractId.html">fuel-types documentation</a>).</p>
<p>These are the main ways of creating a <code>ContractId</code>:</p>
<pre><code class="language-rust ignore">        use std::str::FromStr;

        use fuels::tx::ContractId;

        // Zeroed Bytes32
        let contract_id = ContractId::zeroed();

        // Grab the inner `[u8; 32]` from
        // `Bytes32` by dereferencing (i.e. `*`) it.
        assert_eq!([0u8; 32], *contract_id);

        // From a `[u8; 32]`.
        let my_slice = [1u8; 32];
        let contract_id = ContractId::new(my_slice);
        assert_eq!([1u8; 32], *contract_id);

        // From a string.
        let hex_str = &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;;
        let contract_id =
            ContractId::from_str(hex_str).expect(&quot;failed to create ContractId from string&quot;);
        assert_eq!([0u8; 32], *contract_id);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assetid"><a class="header" href="#assetid">AssetId</a></h1>
<p>Like <code>Bytes32</code>, <code>AssetId</code> is a wrapper on <code>[u8; 32]</code> with similar methods and implements the same traits (see <a href="https://docs.rs/fuel-types/latest/fuel_types/struct.AssetId.html">fuel-types documentation</a>).</p>
<p>These are the main ways of creating an <code>AssetId</code>:</p>
<pre><code class="language-rust ignore">        use std::str::FromStr;

        use fuels::tx::AssetId;

        // Zeroed Bytes32
        let asset_id = AssetId::zeroed();

        // Grab the inner `[u8; 32]` from
        // `Bytes32` by dereferencing (i.e. `*`) it.
        assert_eq!([0u8; 32], *asset_id);

        // From a `[u8; 32]`.
        let my_slice = [1u8; 32];
        let asset_id = AssetId::new(my_slice);
        assert_eq!([1u8; 32], *asset_id);

        // From a string.
        let hex_str = &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;;
        let asset_id = AssetId::from_str(hex_str).expect(&quot;failed to create AssetId from string&quot;);
        assert_eq!([0u8; 32], *asset_id);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-native-types"><a class="header" href="#converting-native-types">Converting native types</a></h1>
<p>You might want to convert between the native types (<code>Bytes32</code>, <code>Address</code>, <code>ContractId</code>, and <code>AssetId</code>). Because these types are wrappers on <code>[u8; 32]</code>, converting is a matter of dereferencing one and instantiating the other using the dereferenced value. Here's an example:</p>
<pre><code class="language-rust ignore">        use fuels::tx::{AssetId, ContractId};

        let contract_id = ContractId::new([1u8; 32]);

        let asset_id: AssetId = AssetId::new(*contract_id);

        assert_eq!([1u8; 32], *asset_id);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bech32"><a class="header" href="#bech32">Bech32</a></h1>
<p><code>Bech32Address</code> and <code>Bech32ContractId</code> enable the use of addresses and contract ids in the bech32 format. They can easily be converted to their counterparts <code>Address</code> and <code>ContractId</code>.</p>
<p>Here are the main ways of creating a <code>Bech32Address</code>, but note that the same applies to <code>Bech32ContractId</code>: </p>
<pre><code class="language-rust ignore">        use fuels::{
            prelude::Bech32Address,
            tx::{Address, Bytes32},
        };

        // New from HRP string and a hash
        let hrp = &quot;fuel&quot;;
        let my_slice = [1u8; 32];
        let _bech32_address = Bech32Address::new(hrp, my_slice);

        // Note that you can also pass a hash stored as Bytes32 to new:
        let my_hash = Bytes32::new([1u8; 32]);
        let _bech32_address = Bech32Address::new(hrp, my_hash);

        // From a string.
        let address = &quot;fuel1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqsx2mt2&quot;;
        let bech32_address =
            Bech32Address::from_str(address).expect(&quot;failed to create Bech32 address from string&quot;);
        assert_eq!([0u8; 32], *bech32_address.hash());

        // From Address
        let plain_address = Address::new([0u8; 32]);
        let bech32_address = Bech32Address::from(plain_address);
        assert_eq!([0u8; 32], *bech32_address.hash());

        // Convert to Address
        let _plain_address: Address = bech32_address.into();

</code></pre>
<blockquote>
<p><strong>Note:</strong> when creating a <code>Bech32Address</code> from <code>Address</code> or <code>Bech32ContractId</code> from <code>ContractId</code> the HRP (Human-Readable Part) is set to <strong>&quot;fuel&quot;</strong> per default.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-and-enums"><a class="header" href="#structs-and-enums">Structs and enums</a></h1>
<p>The structs and enums you define in your Sway code have equivalents automatically generated by the SDK's <code>abigen!</code> macro.</p>
<p>For instance, if in your Sway code you have a struct called <code>CounterConfig</code> that looks like this:</p>
<pre><code class="language-rust ignore">struct CounterConfig {
  dummy: bool,
  initial_value: u64,
}
</code></pre>
<p>After using the <code>abigen!</code> macro, <code>CounterConfig</code> will be accessible in your Rust file! Here's an example:</p>
<pre><code class="language-rust ignore">    abigen!(Contract(name=&quot;MyContract&quot;,
                     abi=&quot;packages/fuels/tests/types/contracts/complex_types_contract/out/debug/complex_types_contract-abi.json&quot;));

    // Here we can use `CounterConfig`, a struct originally
    // defined in the contract.
    let counter_config = CounterConfig {
        dummy: true,
        initial_value: 42,
    };
</code></pre>
<p>You can freely use your custom types (structs or enums) within this scope. That also means passing custom types to functions and receiving custom types from function calls.</p>
<h2 id="manual-decoding"><a class="header" href="#manual-decoding">Manual decoding</a></h2>
<p>Suppose you wish to decode raw bytes into a type used in your contract and the <code>abigen!</code> generated this type, then you can use <code>try_into</code>:</p>
<pre><code class="language-rust ignore">    let shaker_in_bytes: Vec&lt;u8&gt; = vec![0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2];

    let expected = Shaker::Mojito(2);

    // as slice
    let actual: Shaker = shaker_in_bytes[..].try_into()?;
    assert_eq!(actual, expected);

    // as ref
    let actual: Shaker = (&amp;shaker_in_bytes).try_into()?;
    assert_eq!(actual, expected);

    // as value
    let actual: Shaker = shaker_in_bytes.try_into()?;
    assert_eq!(actual, expected);
</code></pre>
<p>Otherwise, for native types such as <code>u8</code>, <code>u32</code>,...,<code>ContractId</code> and others, you must use <code>::fuels::core::try_from_bytes</code>:</p>
<pre><code class="language-rust ignore">        let contract_id_bytes = [0xFF; 32];
        let contract_id = ContractId::new(contract_id_bytes);

        let asset_id_bytes = [0xFF; 32];
        let asset_id = AssetId::new(asset_id_bytes);

        let bytes: Vec&lt;u8&gt; = [contract_id_bytes, asset_id_bytes].concat();
        let expected: (ContractId, AssetId) = try_from_bytes(&amp;bytes)?;

        assert_eq!(expected, (contract_id, asset_id));
</code></pre>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>The Fuel Rust SDK supports both generic enums and generic structs. If you're already familiar with Rust, it's your typical <code>struct MyStruct&lt;T&gt;</code> type of generics support.</p>
<p>For instance, your Sway contract could look like this:</p>
<pre><code class="language-Rust">contract;

use std::hash::sha256;

struct SimpleGeneric&lt;T&gt; {
    single_generic_param: T,
}

abi MyContract {
  fn struct_w_generic(arg1: SimpleGeneric&lt;u64&gt;) -&gt; SimpleGeneric&lt;u64&gt;;
}

impl MyContract for Contract {
    fn struct_w_generic(arg1: SimpleGeneric&lt;u64&gt;) -&gt; SimpleGeneric&lt;u64&gt; {
        let expected = SimpleGeneric {
            single_generic_param: 123u64,
        };

        assert(arg1.single_generic_param == expected.single_generic_param);

        expected
    }
}
</code></pre>
<p>Your Rust code would look like this:</p>
<pre><code class="language-rust ignore">        // simple struct with a single generic param
        let arg1 = SimpleGeneric {
            single_generic_param: 123u64,
        };

        let result = contract_methods
            .struct_w_generic(arg1.clone())
            .call()
            .await?
            .value;

        assert_eq!(result, arg1);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<p>The Rust SDK represents Fuel's <code>String</code>s as <code>SizedAsciiString&lt;LEN&gt;</code>, where the generic parameter <code>LEN</code> is the length of a given string. This abstraction is necessary because all strings in Fuel and Sway are statically-sized, i.e., you must know the size of the string beforehand.</p>
<p>Here's how you can create a simple string using <code>SizedAsciiString</code>:</p>
<pre><code class="language-rust ignore">        let ascii_data = &quot;abc&quot;.to_string();

        SizedAsciiString::&lt;3&gt;::new(ascii_data)
            .expect(&quot;Should have succeeded since we gave ascii data of correct length!&quot;);
</code></pre>
<p>To make working with <code>SizedAsciiString</code>s easier, you can use <code>try_into()</code> to convert from Rust's <code>String</code> to <code>SizedAsciiString</code>, and you can use <code>into()</code> to convert from <code>SizedAsciiString</code> to Rust's <code>String</code>. Here are a few examples:</p>
<pre><code class="language-rust ignore">    #[test]
    fn can_be_constructed_from_str_ref() {
        let _: SizedAsciiString&lt;3&gt; = &quot;abc&quot;.try_into().expect(&quot;Should have succeeded&quot;);
    }

    #[test]
    fn can_be_constructed_from_string() {
        let _: SizedAsciiString&lt;3&gt; = &quot;abc&quot;.to_string().try_into().expect(&quot;Should have succeeded&quot;);
    }

    #[test]
    fn can_be_converted_into_string() {
        let sized_str = SizedAsciiString::&lt;3&gt;::new(&quot;abc&quot;.to_string()).unwrap();

        let str: String = sized_str.into();

        assert_eq!(str, &quot;abc&quot;);
    }
</code></pre>
<p>If your contract's method takes and returns, for instance, a Sway's <code>str[23]</code>. When using the SDK, this method will take and return a <code>SizedAsciiString&lt;23&gt;</code>, and you can pass a string to it like this:</p>
<pre><code class="language-rust ignore">    let call_handler = contract_instance.methods().takes_string(
        &quot;This is a full sentence&quot;
            .try_into()
            .expect(&quot;failed to convert string into SizedAsciiString&quot;),
    );
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bits256"><a class="header" href="#bits256">Bits256</a></h1>
<p>In Fuel, a type called <code>b256</code> represents hashes and holds a 256-bit value. The Rust SDK represents <code>b256</code> as <code>Bits256(value)</code> where <code>value</code> is a <code>[u8; 32]</code>. If your contract method takes a <code>b256</code> as input, you must pass a <code>Bits256([u8; 32])</code> when calling it from the SDK.</p>
<p>Here's an example:</p>
<pre><code class="language-rust ignore">    let arg: [u8; 32] = hasher.finalize().into();

    let call_handler = contract_instance.methods().takes_b256(Bits256(arg));
</code></pre>
<p>If you have a hexadecimal value as a string and wish to convert it to <code>Bits256</code>, you may do so with <code>from_hex_str</code>:</p>
<pre><code class="language-rust ignore">        let hex_str = &quot;0101010101010101010101010101010101010101010101010101010101010101&quot;;

        let bits256 = Bits256::from_hex_str(hex_str)?;

        assert_eq!(bits256.0, [1u8; 32]);

        // With the `0x0` prefix
        let hex_str = &quot;0x0101010101010101010101010101010101010101010101010101010101010101&quot;;

        let bits256 = Bits256::from_hex_str(hex_str)?;

        assert_eq!(bits256.0, [1u8; 32]);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="b512"><a class="header" href="#b512">B512</a></h1>
<p>In the Rust SDK, the <code>B512</code> definition matches the Sway standard library type with the same name and will be converted accordingly when interacting with contracts:</p>
<pre><code class="language-rust ignore">pub struct B512 {
    pub bytes: [Bits256; 2],
}
</code></pre>
<p>Here's an example:</p>
<pre><code class="language-rust ignore">    let hi_bits = Bits256::from_hex_str(
        &quot;0xbd0c9b8792876713afa8bff383eebf31c43437823ed761cc3600d0016de5110c&quot;,
    )?;
    let lo_bits = Bits256::from_hex_str(
        &quot;0x44ac566bd156b4fc71a4a4cb2655d3dd360c695edb17dc3b64d611e122fea23d&quot;,
    )?;
    let b512 = B512::from((hi_bits, lo_bits));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evmaddress"><a class="header" href="#evmaddress">EvmAddress</a></h1>
<p>In the Rust SDK, Ethereum Virtual Machine (EVM) addresses can be represented with the 'EvmAddress' type. Its definition matches with the Sway standard library type with the same name and will be converted accordingly when interacting with contracts:</p>
<pre><code class="language-rust ignore">pub struct EvmAddress {
    // An evm address is only 20 bytes, the first 12 bytes should be set to 0
    value: Bits256,
}
</code></pre>
<p>Here's an example:</p>
<pre><code class="language-rust ignore">    let b256 = Bits256(hasher.finalize().into());
    let arg = EvmAddress::from(b256);

    let call_handler = contract_instance.methods().takes_evm_address(arg);
</code></pre>
<blockquote>
<p><strong>Note:</strong> when creating an <code>EvmAddress</code> from <code>Bits256</code>, the first 12 bytes will be cleared because an evm address is only 20 bytes long.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectors"><a class="header" href="#vectors">Vectors</a></h1>
<h2 id="passing-in-vectors"><a class="header" href="#passing-in-vectors">Passing in vectors</a></h2>
<p>You can pass a Rust <code>std::vec::Vec</code> into your contract method transparently. The following code calls a Sway contract method which accepts a <code>Vec&lt;SomeStruct&lt;u32&gt;&gt;</code>.</p>
<pre><code class="language-rust ignore">        let arg = vec![SomeStruct { a: 0 }, SomeStruct { a: 1 }];
        methods.struct_in_vec(arg.clone()).call().await?;
</code></pre>
<p>You can use a vector just like you would use any other type -- e.g. a <code>[Vec&lt;u32&gt;; 2]</code> or a <code>SomeStruct&lt;Vec&lt;Bits256&gt;&gt;</code> etc.</p>
<h2 id="returning-vectors"><a class="header" href="#returning-vectors">Returning vectors</a></h2>
<p>Returning vectors from contract methods is supported transparently, with the caveat that you cannot have them nested inside another type. This limitation is temporary.</p>
<pre><code class="language-rust ignore">    let response = contract_methods.u8_in_vec(10).call().await?;
    assert_eq!(response.value, (0..10).collect::&lt;Vec&lt;_&gt;&gt;());
</code></pre>
<p>** &gt;Note: you can still interact with contracts containing methods that return vectors nested inside another type, just not interact with the methods themselves **</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<p>For a more in-depth look at the APIs provided by the Fuel Rust SDK, head over to the <a href="https://docs.rs/fuels/latest/fuels/">official documentation</a>. In the actual Rust docs, you can see the most up-to-date information about the API, which is synced with the code as it changes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuels-rs-testing"><a class="header" href="#fuels-rs-testing"><code>fuels-rs</code> Testing</a></h1>
<blockquote>
<p><strong>note</strong> This section is still a work in progress.</p>
</blockquote>
<ul>
<li><a href="testing/./basics.html">Testing Basics</a></li>
<li><a href="testing/./the-setup-contract-test-macro.html"><code>setup_contract_test!</code> Macro</a></li>
<li><a href="testing/./chains.html">Tweaking the Blockchain</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-basics"><a class="header" href="#testing-basics">Testing Basics</a></h1>
<p>If you're new to Rust, you'll want to review these important tools to help you build tests.</p>
<h2 id="the-assert-macro"><a class="header" href="#the-assert-macro">The <code>assert!</code> macro</a></h2>
<p>You can use the <code>assert!</code> macro to assert certain conditions in your test. This macro invokes <code>panic!()</code> and fails the test if the expression inside evaluates to <code>false</code>.</p>
<pre><code class="language-rust  ignore">assert!(value == 5);
</code></pre>
<h2 id="the-assert_eq-macro"><a class="header" href="#the-assert_eq-macro">The <code>assert_eq!</code> macro</a></h2>
<p>The <code>assert_eq!</code> macro works a lot like the <code>assert</code> macro, however instead it accepts two values, and panics if those values are not equal.</p>
<pre><code class="language-rust  ignore">assert_eq!(balance, 100);
</code></pre>
<h2 id="the-assert_ne-macro"><a class="header" href="#the-assert_ne-macro">The <code>assert_ne!</code> macro</a></h2>
<p>The <code>assert_ne!</code> macro works just like the <code>assert_eq!</code> macro, but it will panic if the two values are equal.</p>
<pre><code class="language-rust  ignore">assert_ne!(address, 0);
</code></pre>
<h2 id="the-println-macro"><a class="header" href="#the-println-macro">The <code>println!</code> macro</a></h2>
<p>You can use the <code>println!</code> macro to print values to the console.</p>
<pre><code class="language-rust  ignore">println!(&quot;WALLET 1 ADDRESS {}&quot;, wallet_1.address());
println!(&quot;WALLET 1 ADDRESS {:?}&quot;, wallet_1.address());
</code></pre>
<p>Using <code>{}</code> will print the value, and using <code>{:?}</code> will print the value plus its type.</p>
<p>Using <code>{:?}</code> will also allow you to print values that do not have the <code>Display</code> trait implemented but do have the <code>Debug</code> trait. Alternatively you can use the <code>dbg!</code> macro to print these types of variables.</p>
<pre><code class="language-rust  ignore">println!(&quot;WALLET 1 PROVIDER {:?}&quot;, wallet_1.provider().unwrap());
dbg!(&quot;WALLET 1 PROVIDER {}&quot;, wallet_1.provider().unwrap());
</code></pre>
<p>To print more complex types that don't have it already, you can implement your own formatted display method with the <code>fmt</code> module from the Rust standard library.</p>
<pre><code class="language-rust  ignore">use std::fmt;

struct Point {
    x: u64,
    y: u64,
}

// add print functionality with the fmt module 
impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;value of x: {}, value of y: {}&quot;, self.x, self.y)
    }
}

let p = Point {x: 1, y: 2};
println!(&quot;POINT: {}&quot;, p);
</code></pre>
<h2 id="run-commands"><a class="header" href="#run-commands">Run Commands</a></h2>
<p>You can run your tests to see if they pass or fail with</p>
<pre><code>cargo test
</code></pre>
<p>Outputs will be hidden if the test passes. If you want to see outputs printed from your tests regardless of whether they pass or fail, use the <code>nocapture</code> flag.</p>
<pre><code>cargo test -- --nocapture
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-setup_contract_test-macro"><a class="header" href="#the-setup_contract_test-macro">The setup_contract_test! macro</a></h1>
<p>When deploying contracts with the <code>abigen!</code> macro, as shown in the previous sections, the user can:</p>
<ul>
<li>change the default configuration parameters</li>
<li>launch several providers</li>
<li>create multiple wallets</li>
<li>create specific assets, etc.</li>
</ul>
<p>However, it is often the case that we want to test only the contract methods and we want to deploy the contract with the default configuration parameters. The <code>setup_contract_test!</code> macro can do exactly that.</p>
<hr />
<p>Used to reduce boilerplate in integration tests. Accepts input in the form
of <code>COMMAND(ARG...)...</code></p>
<p><code>COMMAND</code> is either <code>Wallets</code>, <code>Abigen</code> or <code>Deploy</code>.</p>
<p><code>ARG</code> is either a:</p>
<ul>
<li>name-value (e.g. <code>name=&quot;MyContract&quot;</code>), or,</li>
<li>a literal (e.g. <code>&quot;some_str_literal&quot;</code>, <code>true</code>, <code>5</code>, ...)</li>
</ul>
<p>Available <code>COMMAND</code>s:</p>
<h2 id="wallets"><a class="header" href="#wallets">Wallets</a></h2>
<p>Example: <code>Wallets(&quot;a_wallet&quot;, &quot;another_wallet&quot;...)</code></p>
<p>Description: Launches a local provider and generates wallets with names taken from the provided <code>ARG</code>s.</p>
<p>Cardinality: 0 or 1.</p>
<h2 id="abigen-1"><a class="header" href="#abigen-1">Abigen</a></h2>
<p>Example: <code>Abigen(name=&quot;MyContract&quot;, abi=&quot;some_folder&quot;)</code></p>
<p>Description: Generates the contract bindings under the name <code>name</code>. <code>abi</code>
should point to the folder containing the <code>out</code> directory of the forc build.</p>
<p>Cardinality: 0 or N.</p>
<h2 id="deploy"><a class="header" href="#deploy">Deploy</a></h2>
<p>Example: <code>Deploy(name=&quot;instance_name&quot;, contract=&quot;MyContract&quot;, wallet=&quot;a_wallet&quot;)</code></p>
<p>Description: Deploys the <code>contract</code> (with salt) using <code>wallet</code>. Will create a contract instance accessible via <code>name</code>. Due to salt usage, the same contract can be deployed multiple times. Requires that an <code>Abigen</code> command be present with <code>name</code> equal to <code>contract</code>. <code>wallet</code> can either be one of the wallets in the <code>Wallets</code> <code>COMMAND</code> or the name of a wallet you've previously generated yourself.</p>
<p>Cardinality: 0 or N.</p>
<p>The setup code that you have seen in previous sections gets reduced to:</p>
<pre><code class="language-rust ignore">        setup_contract_test!(
            Wallets(&quot;wallet&quot;),
            Abigen(
                name = &quot;TestContract&quot;,
                abi = &quot;packages/fuels/tests/contracts/contract_test&quot;
            ),
            Deploy(
                name = &quot;contract_instance&quot;,
                contract = &quot;TestContract&quot;,
                wallet = &quot;wallet&quot;
            ),
        );

        let response = contract_instance
            .methods()
            .initialize_counter(42)
            .call()
            .await?;

        assert_eq!(42, response.value);
</code></pre>
<blockquote>
<p><strong>Note</strong> The same contract can be deployed several times as the macro deploys the contracts with salt. You can also deploy different contracts to the same provider by referencing the same wallet in the <code>Deploy</code> command.</p>
</blockquote>
<pre><code class="language-rust ignore">    setup_contract_test!(
        Wallets(&quot;wallet&quot;),
        Abigen(
            name = &quot;LibContract&quot;,
            abi = &quot;packages/fuels/tests/contracts/lib_contract&quot;
        ),
        Abigen(
            name = &quot;LibContractCaller&quot;,
            abi = &quot;packages/fuels/tests/contracts/lib_contract_caller&quot;
        ),
        Deploy(
            name = &quot;lib_contract_instance&quot;,
            contract = &quot;LibContract&quot;,
            wallet = &quot;wallet&quot;
        ),
        Deploy(
            name = &quot;contract_caller_instance&quot;,
            contract = &quot;LibContractCaller&quot;,
            wallet = &quot;wallet&quot;
        ),
        Deploy(
            name = &quot;contract_caller_instance2&quot;,
            contract = &quot;LibContractCaller&quot;,
            wallet = &quot;wallet&quot;
        ),
    );
    let lib_contract_id = lib_contract_instance.contract_id();

    let contract_caller_id = contract_caller_instance.contract_id();

    let contract_caller_id2 = contract_caller_instance2.contract_id();

    // Because we deploy with salt, we can deploy the same contract multiple times
    assert_ne!(contract_caller_id, contract_caller_id2);

    // The first contract can be called because they were deployed on the same provider
    let response = contract_caller_instance
        .methods()
        .increment_from_contract(lib_contract_id.into(), 42)
        .set_contracts(&amp;[&amp;lib_contract_instance])
        .call()
        .await?;

    assert_eq!(43, response.value);

    let response = contract_caller_instance2
        .methods()
        .increment_from_contract(lib_contract_id.into(), 42)
        .set_contracts(&amp;[&amp;lib_contract_instance])
        .call()
        .await?;

    assert_eq!(43, response.value);
</code></pre>
<p>In this example, three contracts are deployed on the same provider using the <code>wallet</code> generated by the <code>Wallets</code> command. The second and third macros use the same contract but have different IDs because of the deployment with salt. Both of them can call the first contract by using their ID.</p>
<p>In addition, you can manually create the <code>wallet</code> variable and then use it inside the macro. This is useful if you want to create custom wallets or providers but still want to use the macro to reduce boilerplate code. Below is an example of this approach.</p>
<pre><code class="language-rust ignore">    let config = WalletsConfig::new(Some(2), Some(1), Some(DEFAULT_COIN_AMOUNT));

    let mut wallets = launch_custom_provider_and_get_wallets(config, None, None).await;
    let wallet = wallets.pop().unwrap();
    let wallet_2 = wallets.pop().unwrap();

    setup_contract_test!(
        Abigen(
            name = &quot;TestContract&quot;,
            abi = &quot;packages/fuels/tests/contracts/contract_test&quot;
        ),
        Deploy(
            name = &quot;contract_instance&quot;,
            contract = &quot;TestContract&quot;,
            wallet = &quot;wallet&quot;
        ),
    );
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="increasing-the-block-height"><a class="header" href="#increasing-the-block-height">Increasing the block height</a></h1>
<p>You can use <code>produce_blocks</code> to help achieve an arbitrary block height; this is useful when you want to do any testing regarding transaction maturity.</p>
<blockquote>
<p><strong>Note</strong>: For the <code>produce_blocks</code> API to work, it is imperative to have <code>manual_blocks_enabled = true</code> in the config for the running node. See example below.</p>
</blockquote>
<pre><code class="language-rust ignore">    let config = Config {
        manual_blocks_enabled: true, // Necessary so the `produce_blocks` API can be used locally
        ..Config::local_node()
    };
    let wallets =
        launch_custom_provider_and_get_wallets(WalletsConfig::default(), Some(config), None).await;
    let wallet = &amp;wallets[0];
    let provider = wallet.try_provider()?;

    assert_eq!(provider.latest_block_height().await?, 0);

    provider.produce_blocks(3, None).await?;

    assert_eq!(provider.latest_block_height().await?, 3);
</code></pre>
<p>You can also set a custom block time by providing <code>TimeParameters</code> as the second, optional argument. <code>TimeParameters</code> is defined as:</p>
<pre><code class="language-rust ignore">pub struct TimeParameters {
    // The time to set on the first block
    pub start_time: DateTime&lt;Utc&gt;,
    // The time interval between subsequent blocks
    pub block_time_interval: Duration,
}
</code></pre>
<p>And here is an example:</p>
<pre><code class="language-rust ignore">    let config = Config {
        manual_blocks_enabled: true, // Necessary so the `produce_blocks` API can be used locally
        ..Config::local_node()
    };
    let wallets =
        launch_custom_provider_and_get_wallets(WalletsConfig::default(), Some(config), None).await;
    let wallet = &amp;wallets[0];
    let provider = wallet.try_provider()?;

    assert_eq!(provider.latest_block_height().await?, 0);

    let time = TimeParameters {
        start_time: Utc.timestamp_opt(100, 0).unwrap(),
        block_time_interval: Duration::seconds(10),
    };
    provider.produce_blocks(3, Some(time)).await?;

    assert_eq!(provider.latest_block_height().await?, 3);

    let req = PaginationRequest {
        cursor: None,
        results: 10,
        direction: PageDirection::Forward,
    };
    let blocks: Vec&lt;Block&gt; = provider.get_blocks(req).await?.results;

    assert_eq!(blocks[1].header.time.unwrap().timestamp(), 100);
    assert_eq!(blocks[2].header.time.unwrap().timestamp(), 110);
    assert_eq!(blocks[3].header.time.unwrap().timestamp(), 120);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cookbook"><a class="header" href="#cookbook">Cookbook</a></h1>
<p>This section covers more advanced use cases that can be satisfied by combining various features of the Rust SDK. As such, it assumes that you have already made yourself familiar with the previous chapters of this book.</p>
<blockquote>
<p><strong>note</strong> This section is still a work in progress and more recipes may be added in the future. </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-chain"><a class="header" href="#custom-chain">Custom chain</a></h1>
<p>This example demonstrates how to start a short-lived Fuel node with custom consensus parameters for the underlying chain.</p>
<p>First, we have to import <code>ConsensusParameters</code> from the fuels-tx crate:</p>
<pre><code class="language-rust ignore">        use fuels::tx::ConsensusParameters;
</code></pre>
<p>Next, we can define some values for the consensus parameters:</p>
<pre><code class="language-rust ignore">        let consensus_parameters_config = ConsensusParameters::DEFAULT
            .with_max_gas_per_tx(1000)
            .with_gas_price_factor(10)
            .with_max_inputs(2);
</code></pre>
<p>Before we can start a node, we probably also want to define some genesis coins and assign them to an address:</p>
<pre><code class="language-rust ignore">        let wallet = WalletUnlocked::new_random(None);
        let coins = setup_single_asset_coins(
            wallet.address(),
            Default::default(),
            DEFAULT_NUM_COINS,
            DEFAULT_COIN_AMOUNT,
        );
</code></pre>
<p>Finally, we call <code>setup_test_client()</code>, which starts a node with the given configs and returns a client:</p>
<pre><code class="language-rust ignore">        let node_config = Config::local_node();
        let (client, _) = setup_test_client(
            coins,
            vec![],
            Some(node_config),
            None,
            Some(consensus_parameters_config),
        )
        .await;
        let _provider = Provider::new(client);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deposit-and-withdraw"><a class="header" href="#deposit-and-withdraw">Deposit and withdraw</a></h1>
<p>Consider the following contract:</p>
<pre><code class="language-rust ignore">contract;

use std::{
    call_frames::{
        contract_id,
        msg_asset_id,
    },
    context::msg_amount,
    token::{
        mint_to_address,
        transfer_to_address,
    },
};

abi LiquidityPool {
    #[payable]
    fn deposit(recipient: Address);
    #[payable]
    fn withdraw(recipient: Address);
}

const BASE_TOKEN: b256 = 0x9ae5b658754e096e4d681c548daf46354495a437cc61492599e33fc64dcdc30c;

impl LiquidityPool for Contract {
    #[payable]
    fn deposit(recipient: Address) {
        assert(ContractId::from(BASE_TOKEN) == msg_asset_id());
        assert(0 &lt; msg_amount());

        // Mint two times the amount.
        let amount_to_mint = msg_amount() * 2;

        // Mint some LP token based upon the amount of the base token.
        mint_to_address(amount_to_mint, recipient);
    }

    #[payable]
    fn withdraw(recipient: Address) {
        assert(contract_id() == msg_asset_id());
        assert(0 &lt; msg_amount());

        // Amount to withdraw.
        let amount_to_transfer = msg_amount() / 2;

        // Transfer base token to recipient.
        transfer_to_address(amount_to_transfer, ContractId::from(BASE_TOKEN), recipient);
    }
}
</code></pre>
<p>As its name suggests, it represents a simplified example of a liquidity pool contract. The method <code>deposit()</code> expects you to supply an arbitrary amount of the <code>BASE_TOKEN</code>. As a result, it mints double the amount of the liquidity asset to the calling address. Analogously, if you call <code>withdraw()</code> supplying it with the liquidity asset, it will transfer half that amount of the <code>BASE_TOKEN</code> back to the calling address except for deducting it from the contract balance instead of minting it.</p>
<p>The first step towards interacting with any contract in the Rust SDK is calling the <code>abigen!</code> macro to generate type-safe Rust bindings for the contract methods:</p>
<pre><code class="language-rust ignore">        abigen!(Contract(
            name = &quot;MyContract&quot;,
            abi = &quot;packages/fuels/tests/contracts/liquidity_pool/out/debug/liquidity_pool-abi.json&quot;
        ));
</code></pre>
<p>Next, we set up a wallet with custom-defined assets. We give our wallet some of the contracts <code>BASE_TOKEN</code> and the default asset (required for contract deployment):</p>
<pre><code class="language-rust ignore">        let base_asset_id: AssetId =
            &quot;0x9ae5b658754e096e4d681c548daf46354495a437cc61492599e33fc64dcdc30c&quot;
                .parse()
                .unwrap();

        let asset_ids = [AssetId::default(), base_asset_id];
        let asset_configs = asset_ids
            .map(|id| AssetConfig {
                id,
                num_coins: 1,
                coin_amount: 1_000_000,
            })
            .into();

        let wallet_config = WalletsConfig::new_multiple_assets(1, asset_configs);
        let wallets = launch_custom_provider_and_get_wallets(wallet_config, None, None).await;
        let wallet = &amp;wallets[0];
</code></pre>
<p>Having launched a provider and created the wallet, we can deploy our contract and create an instance of its methods:</p>
<pre><code class="language-rust ignore">        let contract_id = Contract::load_from(
            &quot;../../packages/fuels/tests/contracts/liquidity_pool/out/debug/liquidity_pool.bin&quot;,
            LoadConfiguration::default(),
        )?
        .deploy(wallet, TxParameters::default())
        .await?;

        let contract_methods = MyContract::new(contract_id.clone(), wallet.clone()).methods();
</code></pre>
<p>With the preparations out of the way, we can finally deposit to the liquidity pool by calling <code>deposit()</code> via the contract instance. Since we have to transfer assets to the contract, we create the appropriate <code>CallParameters</code> and chain them to the method call. To receive the minted liquidity pool asset, we have to append a variable output to our contract call.</p>
<pre><code class="language-rust ignore">        let deposit_amount = 1_000_000;
        let call_params = CallParameters::default()
            .set_amount(deposit_amount)
            .set_asset_id(base_asset_id);

        contract_methods
            .deposit(wallet.address().into())
            .call_params(call_params)?
            .append_variable_outputs(1)
            .call()
            .await?;
</code></pre>
<p>As a final demonstration, let's use all our liquidity asset balance to withdraw from the pool and confirm we retrieved the initial amount. For this, we get our liquidity asset balance and supply it to the <code>withdraw()</code> call via <code>CallParameters</code>.</p>
<pre><code class="language-rust ignore">        let lp_asset_id = AssetId::from(*contract_id.hash());
        let lp_token_balance = wallet.get_asset_balance(&amp;lp_asset_id).await?;

        let call_params = CallParameters::default()
            .set_amount(lp_token_balance)
            .set_asset_id(lp_asset_id);

        contract_methods
            .withdraw(wallet.address().into())
            .call_params(call_params)?
            .append_variable_outputs(1)
            .call()
            .await?;

        let base_balance = wallet.get_asset_balance(&amp;base_asset_id).await?;
        assert_eq!(base_balance, deposit_amount);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transfer-all-assets"><a class="header" href="#transfer-all-assets">Transfer all assets</a></h1>
<p>The <code>transfer()</code> method lets you transfer a single asset, but what if you needed to move all of your assets to a different wallet? You could repeatably call <code>transfer()</code>, initiating a transaction each time, or you bundle all the transfers into a single transaction. This chapter guides you through crafting your custom transaction for transferring all assets owned by a wallet.</p>
<p>Lets quickly go over the setup:</p>
<pre><code class="language-rust ignore">        let mut wallet_1 = WalletUnlocked::new_random(None);
        let mut wallet_2 = WalletUnlocked::new_random(None);

        const NUM_ASSETS: u64 = 5;
        const AMOUNT: u64 = 100_000;
        const NUM_COINS: u64 = 1;
        let (coins, _) =
            setup_multiple_assets_coins(wallet_1.address(), NUM_ASSETS, NUM_COINS, AMOUNT);

        let (provider, _) = setup_test_provider(coins, vec![], None, None).await;

        wallet_1.set_provider(provider.clone());
        wallet_2.set_provider(provider.clone());
</code></pre>
<p>We prepare two wallets with randomized addresses. Next, we want one of our wallets to have some random assets, so we set them up with <code>setup_multiple_assets_coins()</code>. Having created the coins, we can start a provider and assign it to the previously created wallets.</p>
<p>Transactions require us to define input and output coins. Let's assume we do not know the assets owned by <code>wallet_1</code>. We retrieve its balances, i.e. tuples consisting of a string representing the asset id and the respective amount. This lets us use the helpers <code>get_asset_inputs_for_amount()</code>, <code>get_asset_outputs_for_amount()</code> to create the appropriate inputs and outputs.</p>
<p>For the sake of simplicity, we avoid transferring the base asset so we don't have to worry about transaction fees:</p>
<pre><code class="language-rust ignore">        let balances = wallet_1.get_balances().await?;

        let mut inputs = vec![];
        let mut outputs = vec![];
        for (id_string, amount) in balances {
            let id = AssetId::from_str(&amp;id_string).unwrap();

            // leave the base asset to cover transaction fees
            if id == BASE_ASSET_ID {
                continue;
            }

            let input = wallet_1
                .get_asset_inputs_for_amount(id, amount, None)
                .await?;
            inputs.extend(input);

            let output = wallet_1.get_asset_outputs_for_amount(wallet_2.address(), id, amount);
            outputs.extend(output);
        }
</code></pre>
<p>All that is left is to build the transaction via <code>ScriptTransactionBuilder</code>, have <code>wallet_1</code> sign it, and we can send it. We confirm this by checking the number of balances present in the receiving wallet and their amount:</p>
<pre><code class="language-rust ignore">        let mut tx =
            ScriptTransactionBuilder::prepare_transfer(inputs, outputs, TxParameters::default())
                .build()?;
        wallet_1.sign_transaction(&amp;mut tx)?;

        let _receipts = provider.send_transaction(&amp;tx).await?;

        let balances = wallet_2.get_balances().await?;

        assert_eq!(balances.len(), (NUM_ASSETS - 1) as usize);
        for (_, balance) in balances {
            assert_eq!(balance, AMOUNT);
        }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<blockquote>
<p><strong>note</strong> This section is still a work in progress.</p>
</blockquote>
<ul>
<li><a href="debugging/./function-selector.html">The Function Selector</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-selector"><a class="header" href="#function-selector">Function selector</a></h1>
<p>Whenever you call a contract method the SDK will generate a function selector according to the fuel specs which will be
used by the node to identify which method we wish to execute.</p>
<p>If, for whatever reason, you wish to generate the function selector yourself you can do so:</p>
<pre><code class="language-rust ignore">        // fn some_fn_name(arg1: Vec&lt;str[3]&gt;, arg2: u8)
        let fn_name = &quot;some_fn_name&quot;;
        let inputs = [Vec::&lt;SizedAsciiString&lt;3&gt;&gt;::param_type(), u8::param_type()];

        let selector = resolve_fn_selector(fn_name, &amp;inputs);

        assert_eq!(selector, [0, 0, 0, 0, 7, 161, 3, 203]);
</code></pre>
<h2 id="if-you-dont-have-the-paramtype"><a class="header" href="#if-you-dont-have-the-paramtype">If you don't have the ParamType</a></h2>
<p>If you won't or can't run the <code>abigen!</code> macro and all you have is the JSON ABI of you contract, you can still get the fn
selector, but you have to jump through an extra hoop to get the ParamTypes:</p>
<pre><code class="language-rust ignore">        let abi: ProgramABI = serde_json::from_str(&amp;abi_file_contents)?;

        let type_lookup = abi
            .types
            .into_iter()
            .map(|a_type| (a_type.type_id, a_type))
            .collect::&lt;HashMap&lt;_, _&gt;&gt;();

        let a_fun = abi
            .functions
            .into_iter()
            .find(|fun| fun.name == &quot;array_of_structs&quot;)
            .unwrap();

        let inputs = a_fun
            .inputs
            .into_iter()
            .map(|type_appl| ParamType::try_from_type_application(&amp;type_appl, &amp;type_lookup))
            .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;

        let selector = resolve_fn_selector(&amp;a_fun.name, &amp;inputs);

        assert_eq!(selector, [0, 0, 0, 0, 39, 152, 108, 146,]);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-fuels-rs"><a class="header" href="#contributing-to-fuels-rs">Contributing to <code>fuels-rs</code></a></h1>
<blockquote>
<p><strong>note</strong> This page is still a work in progress.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-tests-structure-in-fuels-rs"><a class="header" href="#integration-tests-structure-in-fuels-rs">Integration tests structure in <code>fuels-rs</code></a></h1>
<p>The integration tests of <code>fuels-rs</code> cover almost all aspects of the SDK and have grown significantly as more functionality was added. To make the tests and associated <code>Sway</code> projects more manageable they were split into several categories. A category consist of a <code>.rs</code> file for the tests and, if needed, a separate directory for the <code>Sway</code> projects.</p>
<p>Currently have the following structure:</p>
<pre><code>  .
  ├─  bindings/
  ├─  contracts/
  ├─  logs/
  ├─  predicates/
  ├─  storage/
  ├─  types/
  ├─  bindings.rs
  ├─  contracts.rs
  ├─  from_token.rs
  ├─  logs.rs
  ├─  predicates.rs
  ├─  providers.rs
  ├─  scripts.rs
  ├─  storage.rs
  ├─  types.rs
  └─  wallets.rs
</code></pre>
<p>Even though test organization is subjective, please consider these guidelines before adding a new category:</p>
<ul>
<li>Add a new category when creating a new section in the <code>Fuels Rust SDK</code> book - e.g. <code>Types</code></li>
<li>Add a new category if there are more than 3 test and more than 100 lines of code and they form a group of tests - e.g. <code>storage.rs</code></li>
</ul>
<p>Otherwise, we recommend putting the integration test inside the existing categories above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuels-rs-rust-workspaces"><a class="header" href="#fuels-rs-rust-workspaces"><code>fuels-rs</code> Rust Workspaces</a></h1>
<p>This section gives you a little overview of the role and function of every workspace in the <code>fuels-rs</code> repository.</p>
<ul>
<li><a href="cli/./fuels-abi-cli.html"><code>fuels-abi-cli</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuels-abi-cli"><a class="header" href="#fuels-abi-cli"><code>fuels-abi-cli</code></a></h1>
<p>Simple CLI program to encode Sway function calls and decode their output. The ABI being encoded and decoded is specified <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md">here</a>.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-plaintext">sway-abi-cli 0.1.0
FuelVM ABI coder

USAGE:
    sway-abi-cli &lt;SUBCOMMAND&gt;

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    codegen   Output Rust types file
    decode    Decode ABI call result
    encode    Encode ABI call
    help      Prints this message or the help of the given subcommand(s)
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>You can choose to encode only the given params or you can go a step further and have a full JSON ABI file and encode the whole input to a certain function call defined in the JSON file.</p>
<h3 id="encoding-params-only"><a class="header" href="#encoding-params-only">Encoding params only</a></h3>
<pre><code class="language-console">$ cargo run -- encode params -v bool true
0000000000000001
</code></pre>
<pre><code class="language-console">$ cargo run -- encode params -v bool true -v u32 42 -v u32 100
0000000000000001000000000000002a0000000000000064
</code></pre>
<p>Note that for every param you want to encode, you must pass a <code>-v</code> flag followed by the type, and then the value: <code>-v &lt;type_1&gt; &lt;value_1&gt; -v &lt;type_2&gt; &lt;value_2&gt; -v &lt;type_n&gt; &lt;value_n&gt;</code></p>
<h3 id="encoding-function-call"><a class="header" href="#encoding-function-call">Encoding function call</a></h3>
<p><code>example/simple.json</code>:</p>
<pre><code class="language-json">[
  {
    &quot;type&quot;:&quot;function&quot;,
    &quot;inputs&quot;:[
      {
        &quot;name&quot;:&quot;arg&quot;,
        &quot;type&quot;:&quot;u32&quot;
      }
    ],
    &quot;name&quot;:&quot;takes_u32_returns_bool&quot;,
    &quot;outputs&quot;:[
      {
        &quot;name&quot;:&quot;&quot;,
        &quot;type&quot;:&quot;bool&quot;
      }
    ]
  }
]
</code></pre>
<pre><code class="language-console">$ cargo run -- encode function examples/simple.json takes_u32_returns_bool -p 4
000000006355e6ee0000000000000004
</code></pre>
<p><code>example/array.json</code></p>
<pre><code class="language-json">[
  {
    &quot;type&quot;:&quot;function&quot;,
    &quot;inputs&quot;:[
      {
        &quot;name&quot;:&quot;arg&quot;,
        &quot;type&quot;:&quot;u16[3]&quot;
      }
    ],
    &quot;name&quot;:&quot;takes_array&quot;,
    &quot;outputs&quot;:[
      {
        &quot;name&quot;:&quot;&quot;,
        &quot;type&quot;:&quot;u16[2]&quot;
      }
    ]
  }
]
</code></pre>
<pre><code class="language-console">$ cargo run -- encode function examples/array.json takes_array -p '[1,2]'
00000000f0b8786400000000000000010000000000000002
</code></pre>
<p>Note that the first word (8 bytes) of the output is reserved for the function selector, which is captured in the last 4 bytes, which is simply the 256hash of the function signature.</p>
<p>Example with nested struct:</p>
<pre><code class="language-json">[
  {
    &quot;type&quot;:&quot;contract&quot;,
    &quot;inputs&quot;:[
      {
        &quot;name&quot;:&quot;MyNestedStruct&quot;,
        &quot;type&quot;:&quot;struct&quot;,
        &quot;components&quot;:[
          {
            &quot;name&quot;:&quot;x&quot;,
            &quot;type&quot;:&quot;u16&quot;
          },
          {
            &quot;name&quot;:&quot;y&quot;,
            &quot;type&quot;:&quot;struct&quot;,
            &quot;components&quot;:[
              {
                &quot;name&quot;:&quot;a&quot;,
                &quot;type&quot;:&quot;bool&quot;
              },
              {
                &quot;name&quot;:&quot;b&quot;,
                &quot;type&quot;:&quot;u8[2]&quot;
              }
            ]
          }
        ]
      }
    ],
    &quot;name&quot;:&quot;takes_nested_struct&quot;,
    &quot;outputs&quot;:[

    ]
  }
]
</code></pre>
<pre><code class="language-console">$ cargo run -- encode function examples/nested_struct.json takes_nested_struct -p '(10, (true, [1,2]))'
00000000e8a04d9c000000000000000a000000000000000100000000000000010000000000000002
</code></pre>
<h3 id="decoding-params-only"><a class="header" href="#decoding-params-only">Decoding params only</a></h3>
<p>Similar to encoding parameters only:</p>
<pre><code class="language-console">$ cargo run -- decode params -t bool -t u32 -t u32 0000000000000001000000000000002a0000000000000064
Bool(true)
U32(42)
U32(100)
</code></pre>
<h3 id="decoding-function-output"><a class="header" href="#decoding-function-output">Decoding function output</a></h3>
<pre><code class="language-console">$ cargo run -- decode function examples/simple.json takes_u32_returns_bool 0000000000000001
Bool(true)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
