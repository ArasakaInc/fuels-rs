<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Fuel Rust SDK</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">The Fuel Rust SDK</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/setup.html"><strong aria-hidden="true">1.1.</strong> Setting up</a></li><li class="chapter-item expanded "><a href="getting-started/basics.html"><strong aria-hidden="true">1.2.</strong> Basic usage</a></li><li class="chapter-item expanded "><a href="getting-started/wallets.html"><strong aria-hidden="true">1.3.</strong> Wallets</a></li><li class="chapter-item expanded "><a href="getting-started/type-safe-bindings.html"><strong aria-hidden="true">1.4.</strong> Generating type-safe Rust bindings</a></li></ol></li><li class="chapter-item expanded "><a href="testing/index.html"><strong aria-hidden="true">2.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/scripts.html"><strong aria-hidden="true">2.1.</strong> Running scripts</a></li><li class="chapter-item expanded "><a href="testing/chains.html"><strong aria-hidden="true">2.2.</strong> Tweaking the blockchain</a></li></ol></li><li class="chapter-item expanded "><a href="workspaces/index.html"><strong aria-hidden="true">3.</strong> fuels-rs Rust Workspaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="workspaces/fuels-abigen-macro.html"><strong aria-hidden="true">3.1.</strong> fuels-abigen-macro</a></li><li class="chapter-item expanded "><a href="workspaces/fuels-abi-cli.html"><strong aria-hidden="true">3.2.</strong> fuels-abi-cli</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Fuel Rust SDK</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/FuelLabs/fuels-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-fuel-rust-sdk"><a class="header" href="#the-fuel-rust-sdk">The Fuel Rust SDK</a></h1>
<p>Rust SDK for Fuel. It can be used for a variety of things, including but not limited to:</p>
<ul>
<li>Compiling, deploying, and testing <a href="https://github.com/FuelLabs/sway">Sway</a> contracts;</li>
<li>Launching a local Fuel node;</li>
<li>Crafting and signing transactions with hand-crafted scripts or contract calls;</li>
<li>Generating type-safe Rust bindings of contract ABI methods;</li>
<li>And more. <code>fuels-rs</code> is still in active development.</li>
</ul>
<p>This book is an overview of the different things one can achieve using the Rust SDK, and how to implement them. Keep in mind that both the SDK and the documentation are works-in-progress!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This section gives you some pointers for starting to use the Fuel SDK for smart contract
development.</p>
<ul>
<li><a href="getting-started/./setup.html">Setting Up</a></li>
<li><a href="getting-started/./basics.html">Basic Usage</a></li>
<li><a href="getting-started/./wallets.html">Wallets</a></li>
<li><a href="getting-started/./type-safe-bindings.html">Generating Type-safe Rust Bindings</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-instructions-for-the-fuel-sdk"><a class="header" href="#setup-instructions-for-the-fuel-sdk">Setup instructions for the Fuel SDK</a></h1>
<h2 id="what-you-will-need-on-your-machine"><a class="header" href="#what-you-will-need-on-your-machine">What you will need on your machine</a></h2>
<ul>
<li>The latest <code>stable</code> Rust toolchain: <a href="https://fuellabs.github.io/sway/latest/introduction/installation.html#dependencies">https://fuellabs.github.io/sway/latest/introduction/installation.html#dependencies</a></li>
<li><code>forc</code> and <code>fuel-core</code> binaries: <a href="https://fuellabs.github.io/sway/latest/introduction/installation.html">https://fuellabs.github.io/sway/latest/introduction/installation.html</a></li>
</ul>
<p><code>forc</code> is Sway equivalent of Rust's <code>cargo</code>. <code>fuel-core</code> is a Fuel full node implementation.</p>
<p>Now you're up and ready to develop with the Fuel Rust SDK!</p>
<h2 id="importing-the-fuel-rust-sdk"><a class="header" href="#importing-the-fuel-rust-sdk">Importing the Fuel Rust SDK</a></h2>
<p>Add these dependencies on your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">fuels = &quot;0.17&quot;
</code></pre>
<blockquote>
<p><strong>Note</strong> We're using version <code>0.17</code> of the SDK, which is the latest version at the time of this writing.</p>
</blockquote>
<p>And then, in your Rust file that's going to make use of the SDK:</p>
<pre><code class="language-rust ignore">use fuels::prelude::*;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-usage-of-the-sdk"><a class="header" href="#basic-usage-of-the-sdk">Basic Usage of the SDK</a></h1>
<p>At a high level, the Fuel Rust SDK can be used to build Rust-based applications that can run computations on the Fuel Virtual Machine through interactions with contracts written in Sway.</p>
<p>For this interaction to work, the SDK must be able to communicate to a <code>fuel-core</code> node; you have two options at your disposal:</p>
<ol>
<li>Use the SDK's native <code>launch_provider_and_get_wallet()</code> that runs a short-lived test Fuel node;</li>
<li>Run a Fuel node outside your SDK code (using <code>fuel-core</code>) and point your SDK to that node's IP and port.</li>
</ol>
<p>The first option is ideal for contract testing, as you can quickly spin up and tear down nodes between specific test cases.</p>
<p>For application building, you probably want to go with the second option.</p>
<h2 id="instantiating-a-fuel-client"><a class="header" href="#instantiating-a-fuel-client">Instantiating a Fuel client</a></h2>
<p>You can instantiate a Fuel client, pointing to a local Fuel node by
using <a href="https://docs.rs/fuels/*/fuels/client/struct.FuelClient.html"><code>FuelClient</code></a>:</p>
<pre><code class="language-rust ignore">    async fn instantiate_client() -&gt; Result&lt;(), Error&gt; {
        use fuels::client::FuelClient;
        use fuels::node::service::{Config, FuelService};

        let server = FuelService::new_node(Config::local_node()).await?;
        let client = FuelClient::from(server.bound_address);
        assert!(client.health().await?);
        Ok(())
    }
</code></pre>
<p>Alternatively, if you have a Fuel node running separately, you can pass in the <code>SocketAddr</code> to <code>FuelClient::from()</code>.</p>
<h2 id="deploying-a-sway-contract"><a class="header" href="#deploying-a-sway-contract">Deploying a Sway contract</a></h2>
<p>There are two intended ways to deploy a contract</p>
<ul>
<li><code>deploy</code></li>
<li><code>deploy_with_parameters</code></li>
</ul>
<p>If you are only interested in a single instance of your contract then use <code>deploy</code></p>
<pre><code class="language-rust ignore">        // This will generate your contract's methods onto `MyContract`.
        // This means an instance of `MyContract` will have access to all
        // your contract's methods that are running on-chain!
        abigen!(
            MyContract,
            // This path is relative to the workspace (repository) root
            &quot;packages/fuels-abigen-macro/tests/test_projects/contract_test/out/debug/contract_test-abi.json&quot;
        );

        // This helper will launch a local node and provide a test wallet linked to it
        let wallet = launch_provider_and_get_wallet().await;

        // Optional: Configure deployment parameters or use `TxParameters::default()`
        let gas_price = 0;
        let gas_limit = 1_000_000;
        let byte_price = 0;
        let maturity = 0;

        // This will deploy your contract binary onto the chain so that its ID can
        // be used to initialize the instance
        let contract_id = Contract::deploy(
            // This path is relative to the current crate (examples/contracts)
            &quot;../../packages/fuels-abigen-macro/tests/test_projects/contract_test/out/debug/contract_test.bin&quot;,
            &amp;wallet,
            TxParameters::new(
                Some(gas_price),
                Some(gas_limit),
                Some(byte_price),
                Some(maturity)
            ),
            StorageConfiguration::default()
        )
        .await?;

        println!(&quot;Contract deployed @ {:x}&quot;, contract_id);
</code></pre>
<p>You can then use the contract methods very simply:</p>
<pre><code class="language-rust ignore">        // This is an instance of your contract which you can use to make calls to your functions
        let contract_instance = MyContract::new(contract_id.to_string(), wallet);

        let response = contract_instance
            .initialize_counter(42) // Build the ABI call
            .call() // Perform the network call
            .await?;

        assert_eq!(42, response.value);

        let response = contract_instance.increment_counter(10).call().await?;

        assert_eq!(52, response.value);
</code></pre>
<p>Alternatively, if you want multiple instances of the same contract then use <code>deploy_with_parameters</code> and set the salt parameter.</p>
<pre><code class="language-rust ignore">    async fn deploy_with_parameters() -&gt; Result&lt;(), Error&gt; {
        use fuels::prelude::*;
        use rand::prelude::{Rng, SeedableRng, StdRng};

        abigen!(
            MyContract,
            &quot;packages/fuels-abigen-macro/tests/test_projects/contract_test/out/debug/contract_test-abi.json&quot;
        );

        let wallet = launch_provider_and_get_wallet().await;

        let contract_id_1 = Contract::deploy(
            &quot;../../packages/fuels-abigen-macro/tests/test_projects/contract_test/out/debug/contract_test.bin&quot;,
            &amp;wallet,
            TxParameters::default(),        StorageConfiguration::default()

        )
        .await?;

        println!(&quot;Contract deployed @ {:x}&quot;, contract_id_1);

        let rng = &amp;mut StdRng::seed_from_u64(2322u64);
        let salt: [u8; 32] = rng.gen();

        let contract_id_2 = Contract::deploy_with_parameters(
            &quot;../../packages/fuels-abigen-macro/tests/test_projects/contract_test/out/debug/contract_test.bin&quot;,
            &amp;wallet,
            TxParameters::default(),
            StorageConfiguration::default(),
            Salt::from(salt),
        )
        .await?;

        println!(&quot;Contract deployed @ {:x}&quot;, contract_id_2);

        assert_ne!(contract_id_1, contract_id_2);
        Ok(())
    }
</code></pre>
<h3 id="initializing-storage-slots-manually"><a class="header" href="#initializing-storage-slots-manually">Initializing storage slots manually</a></h3>
<p>The storage slots of a contract can be initialized manually from <code>Vec&lt;StorageSlot&gt;</code> where <code>StorageSlot</code> is a struct that holds the key-value pair for a given slot.</p>
<pre><code class="language-rust ignore">    let key = Bytes32::from([1u8; 32]);
    let value = Bytes32::from([2u8; 32]);
    let storage_slot = StorageSlot::new(key, value);
    let storage_vec = vec![storage_slot.clone()];
</code></pre>
<p>Once created, the slots can be used to initialize <code>StorageConfiguration::with_manual_storage</code> which can finally be passed to <code>deploy_with_parameters</code>:</p>
<pre><code class="language-rust ignore">    let contract_id = Contract::deploy_with_parameters(
        &quot;tests/test_projects/contract_storage_test/out/debug/contract_storage_test.bin&quot;,
        &amp;wallet,
        TxParameters::default(),
        StorageConfiguration::with_manual_storage(Some(storage_vec)),
        Salt::from([0; 32]),
    )
    .await?;
</code></pre>
<h3 id="initializing-storage-slots-automatically"><a class="header" href="#initializing-storage-slots-automatically">Initializing storage slots automatically</a></h3>
<p>The storage slots of a contract can be initialized automatically from the JSON file generated by the sway compiler.</p>
<p>Path to JSON file is used to initialize <code>StorageConfiguration::with_storage_path</code> which was then passed to <code>deploy_with_parameters</code>:</p>
<pre><code class="language-rust ignore">    let contract_id = Contract::deploy_with_parameters(
        &quot;tests/test_projects/contract_storage_test/out/debug/contract_storage_test.bin&quot;,
        &amp;wallet,
        TxParameters::default(),
        StorageConfiguration::with_storage_path(
            Some(&quot;tests/test_projects/contract_storage_test/out/debug/contract_storage_test-storage_slots.json&quot;.to_string())),
        Salt::default(),
    )
        .await?;
</code></pre>
<h3 id="initializing-storage-slots-both-automatically-and-manually"><a class="header" href="#initializing-storage-slots-both-automatically-and-manually">Initializing storage slots both automatically and manually</a></h3>
<p>We can initialize the slots both automatically and manually by using <code>StorageConfiguration::new()</code>.
If we this, then the generated <code>Vec&lt;StorageSlot&gt;</code> will be merged and the <code>manually</code> generated <code>Vec&lt;StorageSlot&gt;</code> takes precedence.</p>
<h2 id="setting-up-multiple-test-wallets"><a class="header" href="#setting-up-multiple-test-wallets">Setting up multiple test wallets</a></h2>
<p>If you need multiple test wallets, they can be setup as follows:</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;
        // This helper will launch a local node and provide 10 test wallets linked to it.
        // The initial balance defaults to 1 coin per wallet with an amount of 1_000_000_000
        let wallets = launch_custom_provider_and_get_wallets(WalletsConfig::default(), None).await;
</code></pre>
<p>The returned test wallets can be customized via <code>WalletsConfig</code></p>
<pre><code class="language-rust ignore">        let num_wallets = 5;
        let coins_per_wallet = 3;
        let amount_per_coin = 100;

        let config = WalletsConfig::new(
            Some(num_wallets),
            Some(coins_per_wallet),
            Some(amount_per_coin),
        );
        // Launches a local node and provides test wallets as specified by the config
        let wallets = launch_custom_provider_and_get_wallets(config, None).await;
</code></pre>
<h2 id="setting-up-a-test-wallet-with-multiple-assets"><a class="header" href="#setting-up-a-test-wallet-with-multiple-assets">Setting up a test wallet with multiple assets</a></h2>
<p>You can create a test wallet which contains multiple different assets (including the base asset to pay for gas).</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;
        let mut wallet = LocalWallet::new_random(None);
        let num_assets = 5; // 5 different assets
        let coins_per_asset = 10; // Per asset id, 10 coins in the wallet
        let amount_per_coin = 15; // For each coin (UTXO) of the asset, amount of 15

        let (coins, asset_ids) = setup_multiple_assets_coins(
            wallet.address(),
            num_assets,
            coins_per_asset,
            amount_per_coin,
        );
        let (provider, _socket_addr) = setup_test_provider(coins.clone(), None).await;
        wallet.set_provider(provider);
</code></pre>
<ul>
<li><code>coins: Vec&lt;(UtxoId, Coin)&gt;</code> has <code>num_assets * coins_per_assets</code> coins (UTXOs)</li>
<li><code>asset_ids: Vec&lt;AssetId&gt;</code> contains the <code>num_assets</code> randomly generated <code>AssetId</code>s (always includes the base asset)</li>
</ul>
<h2 id="calling-and-configuring-contract-calls"><a class="header" href="#calling-and-configuring-contract-calls">Calling and configuring contract calls</a></h2>
<p>Once you've deployed your contract, as seen in the previous section, you'll likely want to call contract methods and configure some parameters such as gas price, byte price, gas limit, and forward coins in your contract call.</p>
<p>Start by creating an instance of your contract once you have a wallet set up:</p>
<pre><code class="language-rust ignore">        let contract_instance = MyContract::new(contract_id.to_string(), wallet.clone());
</code></pre>
<p>Then we move to configuring contract calls.</p>
<h3 id="txparameters"><a class="header" href="#txparameters"><code>TxParameters</code></a></h3>
<p>Transaction parameters are:</p>
<ol>
<li>Gas price;</li>
<li>Gas limit;</li>
<li>Byte price;</li>
<li>Maturity.</li>
</ol>
<p>These parameters can be configured by creating an instance of <a href="https://github.com/FuelLabs/fuels-rs/blob/adf81bd451d7637ce0976363bd7784408430031a/packages/fuels-contract/src/parameters.rs#L7"><code>TxParameters</code></a> and passing it to a chain method called <code>tx_params</code>:</p>
<pre><code class="language-rust ignore">        // In order: gas_price, gas_limit, byte_price, and maturity
        let my_tx_params = TxParameters::new(None, Some(1_000_000), None, None);

        let response = contract_instance
            .initialize_counter(42) // Our contract method.
            .tx_params(my_tx_params) // Chain the tx params setting method.
            .call() // Perform the contract call.
            .await?; // This is an async call, `.await` for it.

</code></pre>
<p>You can also use <code>TxParameters::default()</code> to use the default values:</p>
<pre><code class="language-rust ignore">pub const DEFAULT_GAS_LIMIT: u64 = 1_000_000;
pub const DEFAULT_GAS_PRICE: u64 = 0;
pub const DEFAULT_BYTE_PRICE: u64 = 0;
pub const DEFAULT_MATURITY: u64 = 0;
</code></pre>
<p>this way:</p>
<pre><code class="language-rust ignore">        let response = contract_instance
            .initialize_counter(42)
            .tx_params(TxParameters::default())
            .call()
            .await?;

</code></pre>
<h3 id="callparameters"><a class="header" href="#callparameters"><code>CallParameters</code></a></h3>
<p>Call parameters are:</p>
<ol>
<li>Amount;</li>
<li>Asset ID;</li>
<li>Gas forwarded.</li>
</ol>
<p>This is commonly used to forward coins to a contract. These parameters can be configured by creating an instance of <a href="https://github.com/FuelLabs/fuels-rs/blob/adf81bd451d7637ce0976363bd7784408430031a/packages/fuels-contract/src/parameters.rs#L15"><code>CallParameters</code></a> and passing it to a chain method called <code>call_params</code>.</p>
<p>For instance, suppose the following contract that makes use of Sway's <code>msg_amount()</code> to return the amount sent in that transaction.</p>
<pre><code class="language-rust ignore">    fn get_msg_amount() -&gt; u64 {
        msg_amount()
    }
</code></pre>
<p>Then, in Rust, after setting up and deploying the above contract, you can configure the amount being sent in the transaction like this:</p>
<pre><code class="language-rust ignore">
        let tx_params = TxParameters::default();

        // Forward 1_000_000 coin amount of base asset_id
        // this is a big number for checking that amount can be a u64
        let call_params = CallParameters::new(Some(1_000_000), None, None);

        let response = contract_instance
            .get_msg_amount() // Our contract method.
            .tx_params(tx_params) // Chain the tx params setting method.
            .call_params(call_params) // Chain the call params setting method.
            .call() // Perform the contract call.
            .await?;
</code></pre>
<p>You can also use <code>CallParameters::default()</code> to use the default values:</p>
<pre><code class="language-rust ignore">// Limit for the actual contract call
pub const DEFAULT_FORWARDED_GAS: u64 = 1_000_000;
// Lower limit when querying spendable UTXOs
pub const DEFAULT_SPENDABLE_COIN_AMOUNT: u64 = 1_000_000;
// Bytes representation of the asset ID of the &quot;base&quot; asset used for gas fees.
pub const BASE_ASSET_ID: AssetId = AssetId::new([0u8; 32]);
</code></pre>
<p>this way:</p>
<pre><code class="language-rust ignore">        let response = contract_instance
            .initialize_counter(42)
            .call_params(CallParameters::default())
            .call()
            .await?;

</code></pre>
<p>The <code>gas_forwarded</code> parameter defines the limit for the actual contract call as opposed to the gas limit for the whole transaction. This means that it is constrained by the transaction limit. If it is set to an amount greater than the available gas, all available gas will be forwarded.</p>
<pre><code class="language-rust ignore">        // Set the transaction `gas_limit` to 1000 and `gas_forwarded` to 200 to specify that the
        // contract call transaction may consume up to 1000 gas, while the actual call may only use 200
        // gas
        let tx_params = TxParameters::new(None, Some(1000), None, None);
        let call_params = CallParameters::new(None, None, Some(200));

        let response = contract_instance
            .get_msg_amount() // Our contract method.
            .tx_params(tx_params) // Chain the tx params setting method.
            .call_params(call_params) // Chain the call params setting method.
            .call() // Perform the contract call.
            .await?;
</code></pre>
<h3 id="callresponse-reading-returned-values"><a class="header" href="#callresponse-reading-returned-values"><code>CallResponse</code>: Reading returned values</a></h3>
<p>You've probably noticed that you're often chaining <code>.call().await.unwrap()</code>. That's because:</p>
<ol>
<li>You have to choose between <code>.call()</code> and <code>.simulate()</code> (more on this in the next section);</li>
<li>Contract calls are asynchronous, so you can choose to either <code>.await</code> it or perform concurrent tasks, making full use of Rust's async;</li>
<li><code>.unwrap()</code> the <code>Result&lt;CallResponse, Error&gt;</code> returned by the contract call.</li>
</ol>
<p>Once you unwrap the <code>CallResponse</code>, you have access to this struct:</p>
<pre><code class="language-rust ignore">pub struct CallResponse&lt;D&gt; {
    pub value: D,
    pub receipts: Vec&lt;Receipt&gt;,
    pub logs: Vec&lt;String&gt;,
}
</code></pre>
<p>Where <code>value</code> will hold the value returned by its respective contract method, represented by the exact type returned by the FuelVM. E.g., if your contract returns a FuelVM's <code>u64</code>, <code>value</code>'s <code>D</code> will be a <code>u64</code>. If it's a FuelVM's tuple <code>(u8,bool)</code>, then <code>D</code> will be a <code>(u8,bool)</code>. If it's a custom type, for instance, a Sway struct <code>MyStruct</code> containing 2 components, a <code>u64</code> and a <code>b256</code>, <code>D</code> will be a struct generated at compile-time, called <code>MyStruct</code> with <code>u64</code> and a <code>[u8; 32]</code> (the equivalent of <code>b256</code> in Rust-land).</p>
<p><code>receipts</code> will hold all <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#receipt">receipts</a> generated by that specific contract call.</p>
<p>And lastly, <code>logs</code> will hold all logs that happened within that specific contract call.</p>
<p>In order to log out <code>receipts</code> values during testing you have to run <code>test</code> as follows:</p>
<pre><code class="language-sh">RUST_LOG=receipts cargo test --test harness $NAME_OF_TEST
</code></pre>
<h3 id="read-only-contract-calls"><a class="header" href="#read-only-contract-calls">Read-only contract calls</a></h3>
<p>Sometimes you want to call a contract method that doesn't change the state of the blockchain. For instance, a method that only reads a value from storage and returns it.</p>
<p>In this case, there's no need to generate an actual blockchain transaction; you only want to quickly read a value.</p>
<p>You can do this with the SDK. Instead of <code>.call()</code>ing the method, use <code>.simulate()</code>:</p>
<pre><code class="language-rust ignore">        // you would mint 100 coins if the transaction wasn't simulated
        let counter = contract_instance.mint_coins(100).simulate().await?;
</code></pre>
<p>Note that if you use <code>.simulate()</code> on a method that <em>does</em> change the state of the blockchain, it won't work properly; it will just <code>dry-run</code> it.</p>
<p>At the moment, it's up to you to know whether a contract method changes state or not, and use <code>.call()</code> or <code>.simulate()</code> accordingly.</p>
<h3 id="variable-outputs"><a class="header" href="#variable-outputs">Variable outputs</a></h3>
<p>In some cases, you might want to send funds to the output of a transaction. Sway has a specific method for that: <code>transfer_to_output(coins, asset_id, recipient)</code>. So, if you have a contract that does something like this:</p>
<pre><code class="language-rust ignore">    fn transfer_coins_to_output(coins: u64, asset_id: ContractId, recipient: Address) {
        transfer_to_output(coins, asset_id, recipient);
    }
</code></pre>
<p>With the SDK, you can call <code>transfer_coins_to_output</code>, by chaining <code>append_variable_outputs(amount)</code> to your contract call. Like this:</p>
<pre><code class="language-rust ignore">        let address = wallet.address();

        // withdraw some tokens to wallet
        let response = contract_instance
            .transfer_coins_to_output(1_000_000, contract_id, address)
            .append_variable_outputs(1)
            .call()
            .await?;
</code></pre>
<p><code>append_variable_outputs</code> effectively appends a given amount of <code>Output::Variable</code>s to the transaction's list of outputs. This output type indicates that the output's amount and owner may vary based on transaction execution.</p>
<p>Note that the Sway <code>lib-std</code> function <code>mint_to_address</code> calls <code>transfer_to_output</code> under the hood, and so you need to call <code>append_variable_outputs</code> in the Rust SDK tests just like you would for <code>transfer_to_output</code>.</p>
<h3 id="contract-calls-calling-other-contracts"><a class="header" href="#contract-calls-calling-other-contracts">Contract calls calling other contracts</a></h3>
<p>Sometimes, you might need to call your contract, which calls other contracts. To do so, you must feed the external contract IDs that your contract depends on to the method you're calling. You do it by chaining <code>.set_contracts(&amp;[external_contract_id, ...])</code> to the method you want to call. For instance:</p>
<pre><code class="language-rust ignore">    let res = foo_caller_contract_instance
        .call_foo_contract(*foo_contract_id, true)
        .set_contracts(&amp;[foo_contract_id]) // Sets the external contract
        .call()
        .await?;
</code></pre>
<p>For a more concrete example, see the <code>test_contract_calling_contract</code> function in
<code>fuels-abigen-macro/tests/harness.rs</code></p>
<h2 id="connecting-to-existing-contracts"><a class="header" href="#connecting-to-existing-contracts">Connecting to existing contracts</a></h2>
<p>If you already have a deployed contract and want to call its methods using the SDK,  but without deploying it again, all you need is the contract ID of your deployed contract. You can skip the whole deployment setup and call <code>::new(contract_id, wallet)</code> directly. For example:</p>
<pre><code class="language-rust ignore">        // Replace with your contract ABI.json path
        abigen!(
        MyContract,
        &quot;packages/fuels-abigen-macro/tests/test_projects/contract_test/out/debug/contract_test-abi.json&quot;
    );
        let wallet = launch_provider_and_get_wallet().await;
        // Your contract ID as a String.
        let contract_id =
            &quot;0x068fe90ddc43b18a8f76756ecad8bf30eb0ceea33d2e6990c0185d01b0dbb675&quot;.to_string();

        let connected_contract_instance = MyContract::new(contract_id, wallet);
        // You can now use the `connected_contract_instance` just as you did above!
</code></pre>
<h2 id="getting-the-contract-call-outputs"><a class="header" href="#getting-the-contract-call-outputs">Getting the contract call outputs</a></h2>
<ul>
<li>Getting the contract call outputs is done this way:</li>
</ul>
<pre><code class="language-rust ignore">        let response = contract_instance.increment_counter(162).call().await;
        match response {
            // The transaction is valid and executes to completion
            Ok(call_response) =&gt; {
                let logs: Vec&lt;String&gt; = call_response.logs;
                let receipts: Vec&lt;Receipt&gt; = call_response.receipts;
                // Do things with logs and receipts
            }

            // The transaction is invalid or node is offline
            // OR
            // The transaction is valid but reverts
            Err(ContractCallError(reason, receipts)) =&gt; {
                println!(&quot;ContractCall failed with reason: {}&quot;, reason);
                println!(&quot;Transaction receipts are: {:?}&quot;, receipts);
            }
            Err(_) =&gt; {}
        }
</code></pre>
<blockquote>
<p><strong>Note:</strong> It is generally considered good practice when you expect the call to succeed, to unwrap the response with <code>?</code>, this way:</p>
<pre><code class="language-rust  ignore">        let response = contract_instance.increment_counter(162).call().await?;
</code></pre>
</blockquote>
<h2 id="multiple-contract-calls-in-a-single-transaction"><a class="header" href="#multiple-contract-calls-in-a-single-transaction">Multiple contract calls in a single transaction</a></h2>
<p>With <code>ContractMultiCallHandler</code> you can execute multiple contract calls within a single transaction. To achieve this, you first prepare all the contract calls that you want to bundle:</p>
<pre><code class="language-rust ignore">        let contract_instance = MyContract::new(contract_id.to_string(), wallet.clone());

        let call_handler_1 = contract_instance.initialize_counter(42);
        let call_handler_2 = contract_instance.get_array([42; 2].to_vec());
</code></pre>
<p>At this point you can also choose to set call parameters, variable outputs or external contracts for every contract call, as long as you don't execute it with <code>call()</code> or <code>simulate()</code>.
Next, you provide the prepared calls to your <code>ContractMultiCallHandler</code> and optionally configure transaction parameters:</p>
<pre><code class="language-rust ignore">        let mut multi_call_handler = MultiContractCallHandler::new(wallet.clone());

        multi_call_handler
            .add_call(call_handler_1)
            .add_call(call_handler_2);
</code></pre>
<p>Note that any transaction parameters configured on separate contract calls are disregarded in favor of the parameters provided to <code>ContractMultiCallHandler</code>.</p>
<h3 id="output-values"><a class="header" href="#output-values">Output values</a></h3>
<p>To get the output values of the bundled calls, you need to provide explicit type annotations when saving the result of <code>call()</code> or <code>simulate()</code> to a variable:</p>
<pre><code class="language-rust ignore">        let (counter, array): (u64, Vec&lt;u64&gt;) = multi_call_handler.call().await?.value;
</code></pre>
<p>You can also interact with the <code>CallResponse</code> by moving the type annotation to the invoked method:</p>
<pre><code class="language-rust ignore">        let response = multi_call_handler.call::&lt;(u64, Vec&lt;u64&gt;)&gt;().await?;
</code></pre>
<h2 id="more-examples"><a class="header" href="#more-examples">More examples</a></h2>
<p>You can find runnable examples under <a href="https://github.com/FuelLabs/fuels-rs/blob/master/packages/fuels-abigen-macro/tests/harness.rs"><code>fuels-abigen-macro/tests/harness.rs</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-wallets"><a class="header" href="#managing-wallets">Managing Wallets</a></h1>
<p>Wallets are used for many important things, for instance:</p>
<ol>
<li>Checking your balance;</li>
<li>Transferring coins to a destination address;</li>
<li>Signing messages and transactions;</li>
<li>Paying for network fees when sending transactions or deploying smart contracts.</li>
</ol>
<p>The SDK gives you many different ways to create wallets. Let's explore these different ways.</p>
<h2 id="creating-a-wallet"><a class="header" href="#creating-a-wallet">Creating a wallet</a></h2>
<p>A new wallet with a randomly generated private key can be created by supplying <code>Option&lt;Provider&gt;</code>.</p>
<pre><code class="language-rust ignore">    async fn create_random_wallet() {
        use fuels::prelude::*;

        // Use the test helper to setup a test provider.
        let (provider, _address) = setup_test_provider(vec![], None).await;

        // Create the wallet.
        let _wallet = LocalWallet::new_random(Some(provider));
    }
</code></pre>
<p>Alternatively, you can create a wallet from a predefined <code>SecretKey</code>.</p>
<pre><code class="language-rust ignore">    async fn create_wallet_from_secret_key() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        use fuels::prelude::*;
        use fuels::signers::fuel_crypto::SecretKey;
        use std::str::FromStr;

        // Use the test helper to setup a test provider.
        let (provider, _address) = setup_test_provider(vec![], None).await;

        // Setup the private key.
        let secret = SecretKey::from_str(
            &quot;5f70feeff1f229e4a95e1056e8b4d80d0b24b565674860cc213bdb07127ce1b1&quot;,
        )?;

        // Create the wallet.
        let _wallet = LocalWallet::new_from_private_key(secret, Some(provider));
        Ok(())
    }
</code></pre>
<blockquote>
<p>Note: if <code>None</code> is supplied instead of a provider, any transaction related to the wallet will result
in an error until a provider is linked with <code>set_provider()</code>. The optional parameter
enables defining owners (wallet addresses) of genesis coins before a provider is launched.</p>
</blockquote>
<h2 id="creating-a-wallet-from-a-mnemonic-phrase"><a class="header" href="#creating-a-wallet-from-a-mnemonic-phrase">Creating a wallet from a mnemonic phrase</a></h2>
<p>A mnemonic phrase is a cryptographically-generated sequence of words that's used to derive a private key. For instance: <code>&quot;oblige salon price punch saddle immune slogan rare snap desert retire surprise&quot;;</code> would generate the address <code>0xdf9d0e6c6c5f5da6e82e5e1a77974af6642bdb450a10c43f0c6910a212600185</code>.</p>
<p>In addition to that, we also support <a href="https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets">Hierarchical Deterministic Wallets</a> and <a href="https://learnmeabitcoin.com/technical/derivation-paths">derivation paths</a>. You may recognize the string <code>&quot;m/44'/60'/0'/0/0&quot;</code> from somewhere; that's a derivation path. In simple terms, it's a way to derive many wallets from a single root wallet.</p>
<p>The SDK gives you two wallets from mnemonic instantiation methods: one that takes a derivation path (<code>Wallet::new_from_mnemonic_phrase_with_path</code>) and one that uses the default derivation path, in case you don't want or don't need to configure that (<code>Wallet::new_from_mnemonic_phrase</code>).</p>
<p>Here's how you can create wallets with both mnemonic phrases and derivation paths:</p>
<pre><code class="language-rust ignore">    async fn create_wallet_from_mnemonic() -&gt; Result&lt;(), Error&gt; {
        use fuels::prelude::*;

        let phrase =
            &quot;oblige salon price punch saddle immune slogan rare snap desert retire surprise&quot;;

        // Use the test helper to setup a test provider.
        let (provider, _address) = setup_test_provider(vec![], None).await;

        // Create first account from mnemonic phrase.
        let _wallet = LocalWallet::new_from_mnemonic_phrase_with_path(
            phrase,
            Some(provider.clone()),
            &quot;m/44'/1179993420'/0'/0/0&quot;,
        )?;

        // Or with the default derivation path
        let wallet = LocalWallet::new_from_mnemonic_phrase(phrase, Some(provider))?;

        let expected_address = &quot;f18b6446deb8135544ba60333e5b7522685cd2cf64aa4e4c75df725149850b65&quot;;

        assert_eq!(wallet.address().to_string(), expected_address);
        Ok(())
    }
</code></pre>
<h2 id="creating-a-wallet-and-storing-an-encrypted-json-wallet-to-disk"><a class="header" href="#creating-a-wallet-and-storing-an-encrypted-json-wallet-to-disk">Creating a wallet and storing an encrypted JSON wallet to disk</a></h2>
<p>You can also manage a wallet using <a href="https://cryptobook.nakov.com/symmetric-key-ciphers/ethereum-wallet-encryption">JSON wallets</a> -- wallets that are securely encrypted and stored on disk. This makes it easier to manage multiple wallets, especially for testing purposes.</p>
<p>You can create a random wallet and, at the same time, encrypt and store it. Then, later, you can recover the wallet if you know the master password:</p>
<pre><code class="language-rust ignore">    async fn create_and_restore_json_wallet() -&gt; Result&lt;(), Error&gt; {
        use fuels::prelude::*;

        let dir = std::env::temp_dir();
        let mut rng = rand::thread_rng();

        // Use the test helper to setup a test provider.
        let (provider, _address) = setup_test_provider(vec![], None).await;

        let password = &quot;my_master_password&quot;;

        // Create a wallet to be stored in the keystore.
        let (_wallet, uuid) =
            LocalWallet::new_from_keystore(&amp;dir, &amp;mut rng, password, Some(provider.clone()))?;

        let path = dir.join(uuid);

        let _recovered_wallet = LocalWallet::load_keystore(&amp;path, password, Some(provider))?;
        Ok(())
    }
</code></pre>
<h2 id="encrypting-and-storing-a-wallet-created-from-mnemonic-or-private-key"><a class="header" href="#encrypting-and-storing-a-wallet-created-from-mnemonic-or-private-key">Encrypting and storing a wallet created from mnemonic or private key</a></h2>
<p>If you had already created a wallet using a mnemonic phrase or a private key, you can also encrypt it and save it to disk:</p>
<pre><code class="language-rust ignore">    async fn create_and_store_mnemonic_wallet() -&gt; Result&lt;(), Error&gt; {
        use fuels::prelude::*;

        let dir = std::env::temp_dir();

        let phrase =
            &quot;oblige salon price punch saddle immune slogan rare snap desert retire surprise&quot;;

        // Use the test helper to setup a test provider.
        let (provider, _address) = setup_test_provider(vec![], None).await;

        // Create first account from mnemonic phrase.
        let wallet = LocalWallet::new_from_mnemonic_phrase(phrase, Some(provider))?;

        let password = &quot;my_master_password&quot;;

        // Encrypts and stores it on disk. Can be recovered using `Wallet::load_keystore`.
        let _uuid = wallet.encrypt(&amp;dir, password)?;
        Ok(())
    }
</code></pre>
<h2 id="checking-balances-and-coins"><a class="header" href="#checking-balances-and-coins">Checking balances and coins</a></h2>
<p>First, one should keep in mind that, with UTXOs, each <em>coin</em> is unique. Each UTXO corresponds to a unique <em>coin</em>, and said <em>coin</em> has a corresponding <em>amount</em> (the same way a dollar bill has either 10$ or 5$ face value). So, when you want to query the balance for a given asset ID, you want to query the sum of the amount in each unspent coin. This is done very easily with a wallet:</p>
<pre><code class="language-rust ignore">        let asset_id: AssetId = BASE_ASSET_ID;
        let balance: u64 = wallet.get_asset_balance(&amp;asset_id).await?;
</code></pre>
<p>If you want to query all the balances (i.e. get the balance for each asset IDs in that wallet), then it is as simple as:</p>
<pre><code class="language-rust ignore">        let balances: HashMap&lt;String, u64&gt; = wallet.get_balances().await?;
</code></pre>
<p>The return type is a <code>HashMap</code>, where the key is the <em>asset ID</em> and the value is the corresponding balance.</p>
<h2 id="security"><a class="header" href="#security">Security</a></h2>
<p>Keep in mind that you should never share your private/secret key. And in the case of wallets that were derived from a mnemonic phrase, never share your mnemonic phrase.</p>
<p>If you're planning on storing the wallet on disk, do not store the plain private/secret key and do not store the plain mnemonic phrase. Instead, use <code>Wallet::encrypt</code> to encrypt its content first before saving it to disk.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-type-safe-rust-bindings"><a class="header" href="#generating-type-safe-rust-bindings">Generating Type-safe Rust Bindings</a></h1>
<p>The SDK lets you transform ABI methods of a contract call, specified as JSON objects (which you can get from <a href="https://github.com/FuelLabs/sway/tree/master/forc">Forc</a>) into Rust structs and methods that are type-checked at compile time.</p>
<p>For instance, a contract with two methods: <code>initialize_counter(arg: u64) -&gt; u64</code> and <code>increment_counter(arg: u64) -&gt; u64</code>, with the following JSON ABI:</p>
<pre><code class="language-json ignore">[
  {
    &quot;type&quot;: &quot;function&quot;,
    &quot;inputs&quot;: [
      {
        &quot;name&quot;: &quot;arg&quot;,
        &quot;type&quot;: &quot;u64&quot;
      }
    ],
    &quot;name&quot;: &quot;initialize_counter&quot;,
    &quot;outputs&quot;: [
      {
        &quot;name&quot;: &quot;arg&quot;,
        &quot;type&quot;: &quot;u64&quot;
      }
    ]
  },
  {
    &quot;type&quot;: &quot;function&quot;,
    &quot;inputs&quot;: [
      {
        &quot;name&quot;: &quot;arg&quot;,
        &quot;type&quot;: &quot;u64&quot;
      }
    ],
    &quot;name&quot;: &quot;increment_counter&quot;,
    &quot;outputs&quot;: [
      {
        &quot;name&quot;: &quot;arg&quot;,
        &quot;type&quot;: &quot;u64&quot;
      }
    ]
  }
]
</code></pre>
<p>Can become this (shortened for brevity's sake):</p>
<pre><code class="language-rust ignore">pub struct MyContract {
    contract_id: ContractId,
    wallet: LocalWallet,
}
impl MyContract {
    pub fn new(contract_id: String, wallet: LocalWallet) -&gt; Self {
        let contract_id = ContractId::from_str(&amp;contract_id).expect(&quot;Invalid contract id&quot;);
        Self {
            contract_id,
            wallet,
        }
    }
    #[doc = &quot;Calls the contract's `initialize_counter` (0x00000000ab64e5f2) function&quot;]
    pub fn initialize_counter(&amp;self, arg: u64) -&gt; ContractCallHandler&lt;u64&gt; {
        Contract::method_hash(
            &amp;self.wallet.get_provider().expect(&quot;Provider not set up&quot;),
            self.contract_id,
            &amp;self.wallet,
            [0, 0, 0, 0, 171, 100, 229, 242],
            &amp;[ParamType::U64],
            &amp;[arg.into_token()],
        )
        .expect(&quot;method not found (this should never happen)&quot;)
    }
    #[doc = &quot;Calls the contract's `increment_counter` (0x00000000faf90dd3) function&quot;]
    pub fn increment_counter(&amp;self, arg: u64) -&gt; ContractCallHandler&lt;u64&gt; {
        Contract::method_hash(
            &amp;self.wallet.get_provider().expect(&quot;Provider not set up&quot;),
            self.contract_id,
            &amp;self.wallet,
            [0, 0, 0, 0, 250, 249, 13, 211],
            &amp;[ParamType::U64],
            &amp;[arg.into_token()],
        )
        .expect(&quot;method not found (this should never happen)&quot;)
    }
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> that is all <strong>generated</strong> code. No need to write any of that. Ever.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> the generated code might look different from one version to another, this is just an example to give you an idea of what it looks like.</p>
</blockquote>
<p>And, then, you're able to use it to call the actual methods on the deployed contract:</p>
<pre><code class="language-rust ignore">        // This is an instance of your contract which you can use to make calls to your functions
        let contract_instance = MyContract::new(contract_id.to_string(), wallet);

        let response = contract_instance
            .initialize_counter(42) // Build the ABI call
            .call() // Perform the network call
            .await?;

        assert_eq!(42, response.value);

        let response = contract_instance.increment_counter(10).call().await?;

        assert_eq!(52, response.value);
</code></pre>
<p>To generate these bindings, all you have to do is:</p>
<pre><code class="language-rust ignore">        use fuels::prelude::*;
        // Replace with your own JSON abi path (relative to the root of your crate)
        abigen!(MyContractName, &quot;examples/rust_bindings/src/abi.json&quot;);
</code></pre>
<p>And this <code>abigen!</code> macro will <em>expand</em> the code with the type-safe Rust bindings. It takes 2 arguments:</p>
<ol>
<li>The name of the struct that will be generated (<code>MyContractName</code>);</li>
<li>Either a path as string to the JSON ABI file or the JSON ABI as a multiline string directly.</li>
</ol>
<p>The same as the example above but passing the ABI definition directly:</p>
<pre><code class="language-rust ignore">        // Don't forget to import the `abigen` macro as above
        abigen!(
            MyContract,
            r#&quot;
    [
        {
            &quot;type&quot;: &quot;function&quot;,
            &quot;inputs&quot;: [
                {
                    &quot;name&quot;: &quot;arg&quot;,
                    &quot;type&quot;: &quot;u64&quot;
                }
            ],
            &quot;name&quot;: &quot;initialize_counter&quot;,
            &quot;outputs&quot;: [
                {
                    &quot;name&quot;: &quot;arg&quot;,
                    &quot;type&quot;: &quot;u64&quot;
                }
            ]
        },
        {
            &quot;type&quot;: &quot;function&quot;,
            &quot;inputs&quot;: [
                {
                    &quot;name&quot;: &quot;arg&quot;,
                    &quot;type&quot;: &quot;u64&quot;
                }
            ],
            &quot;name&quot;: &quot;increment_counter&quot;,
            &quot;outputs&quot;: [
                {
                    &quot;name&quot;: &quot;arg&quot;,
                    &quot;type&quot;: &quot;u64&quot;
                }
            ]
        }
    ]
    &quot;#
        );
</code></pre>
<h2 id="manual-decoding"><a class="header" href="#manual-decoding">Manual decoding</a></h2>
<p>If, for whatever reason, you find yourself with bytes you wish to decode into a type used in your contract.</p>
<p>If it is a type generated by <code>abigen!</code> then you can use <code>try_into</code>:</p>
<pre><code class="language-rust ignore">    let shaker_in_bytes: Vec&lt;u8&gt; = vec![0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2];

    let expected = Shaker::Mojito(2);

    // as slice
    let actual: Shaker = shaker_in_bytes[..].try_into()?;
    assert_eq!(actual, expected);

    // as ref
    let actual: Shaker = (&amp;shaker_in_bytes).try_into()?;
    assert_eq!(actual, expected);

    // as value
    let actual: Shaker = shaker_in_bytes.try_into()?;
    assert_eq!(actual, expected);

</code></pre>
<p>Otherwise, for native types such as <code>u8</code>, <code>u32</code>,...,<code>ContractId</code> and others, you must use
<code>::fuels::core::try_from_bytes</code>:</p>
<pre><code class="language-rust ignore">        let contract_id_bytes = [0xFF; 32];
        let contract_id = ContractId::new(contract_id_bytes);

        let asset_id_bytes = [0xFF; 32];
        let asset_id = AssetId::new(asset_id_bytes);

        let bytes: Vec&lt;u8&gt; = [contract_id_bytes, asset_id_bytes].concat();
        let expected: (ContractId, AssetId) = try_from_bytes(&amp;bytes)?;

        assert_eq!(expected, (contract_id, asset_id));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuels-rs-testing"><a class="header" href="#fuels-rs-testing"><code>fuels-rs</code> Testing</a></h1>
<p>Here you'll find an overview of the various test helpers located in <code>fuels-test-helpers</code>:</p>
<ul>
<li><a href="testing/./scripts.html">Running scripts</a></li>
<li><a href="testing/./chains.html">Tweaking the blockchain</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="running-a-sway-script"><a class="header" href="#running-a-sway-script">Running a Sway script</a></h2>
<p><code>run_compiled_script</code> is a helper function for testing simple Sway scripts and reducing  boilerplate  code  related to setting up contracts and deployment. It takes the path to the generated <code>.bin</code> file as argument.</p>
<ul>
<li>You can use it this way:</li>
</ul>
<pre><code class="language-rust ignore">        let path_to_bin = &quot;../fuels-abigen-macro/tests/test_projects/logging/out/debug/logging.bin&quot;;
        let return_val = run_compiled_script(path_to_bin).await?;

        let correct_hex =
            hex::decode(&quot;ef86afa9696cf0dc6385e2c407a6e159a1103cefb7e2ae0636fb33d3cb2a9e4a&quot;);

        assert_eq!(correct_hex?, return_val[0].data().unwrap());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="increase-the-block-height"><a class="header" href="#increase-the-block-height">Increase the block height</a></h2>
<p><code>produce_blocks</code> can be used to help achieve a desired block height. Useful for when you want to do any testing regarding transaction maturity.</p>
<p>Example of usage:</p>
<pre><code class="language-rust ignore">    let wallet = launch_provider_and_get_wallet().await;
    let provider = &amp;wallet.get_provider().unwrap();

    assert_eq!(provider.latest_block_height().await?, 0);

    produce_blocks(&amp;wallet, 3).await?;

    assert_eq!(provider.latest_block_height().await?, 3);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuels-rs-rust-workspaces"><a class="header" href="#fuels-rs-rust-workspaces"><code>fuels-rs</code> Rust Workspaces</a></h1>
<p>This section gives you a little overview of the role and function of every workspace in the <code>fuels-rs</code> repository.</p>
<ul>
<li><a href="workspaces/./fuels-abigen-macro.html"><code>fuels-abigen-macro</code></a></li>
<li><a href="workspaces/./fuels-abi-cli.html"><code>fuels-abi-cli</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuels-abigen-macro"><a class="header" href="#fuels-abigen-macro"><code>fuels-abigen-macro</code></a></h1>
<p><code>fuels-rs</code>'s abigen is a procedural macro used to transform a contract's ABI defined as a JSON object into type-safe Rust bindings, i.e. Rust structs and types that represent that contract's ABI. These bindings are then expanded and brought into scope.</p>
<p>The specifications for the JSON ABI format and its encoding/decoding can be found <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#json-abi-format">here</a>.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>A simple example of generating type-safe bindings from a JSON ABI specified in-line:</p>
<pre><code class="language-rust ignore">    // Generates the bindings from the an ABI definition inline.
    // The generated bindings can be accessed through `SimpleContract`.
    abigen!(
        SimpleContract,
        r#&quot;
        [
            {
                &quot;type&quot;: &quot;function&quot;,
                &quot;inputs&quot;: [
                    {
                        &quot;name&quot;: &quot;only_argument&quot;,
                        &quot;type&quot;: &quot;u32&quot;
                    }
                ],
                &quot;name&quot;: &quot;takes_ints_returns_bool&quot;,
                &quot;outputs&quot;: [
                    {
                        &quot;name&quot;: &quot;&quot;,
                        &quot;type&quot;: &quot;bool&quot;
                    }
                ]
            }
        ]
        &quot;#,
    );

    let wallet = launch_provider_and_get_wallet().await;
    //`SimpleContract` is the name of the contract
    let contract_instance = SimpleContract::new(null_contract_id(), wallet);

    let call_handler = contract_instance.takes_ints_returns_bool(42_u32);

    let encoded = format!(
        &quot;{}{}&quot;,
        hex::encode(call_handler.contract_call.encoded_selector),
        hex::encode(call_handler.contract_call.encoded_args)
    );

    assert_eq!(&quot;000000009593586c000000000000002a&quot;, encoded);
</code></pre>
<p>This example and many more can be found under <code>tests/harness.rs</code>. To run the whole test suite run <code>cargo test</code> inside <code>fuels-abi-gen-macro/</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuels-abi-cli"><a class="header" href="#fuels-abi-cli"><code>fuels-abi-cli</code></a></h1>
<p>Simple CLI program to encode Sway function calls and decode their output. The ABI being encoded and decoded is specified <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md">here</a>.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<pre><code class="language-plaintext">sway-abi-cli 0.1.0
Sway/Fuel ABI coder

USAGE:
    sway-abi-cli &lt;SUBCOMMAND&gt;

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    codegen   Output Rust types file
    decode    Decode ABI call result
    encode    Encode ABI call
    help      Prints this message or the help of the given subcommand(s)
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>You can choose to encode only the given params or you can go a step further and have a full JSON ABI file and encode the whole input to a certain function call defined in the JSON file.</p>
<h3 id="encoding-params-only"><a class="header" href="#encoding-params-only">Encoding params only</a></h3>
<pre><code class="language-console">$ cargo run -- encode params -v bool true
0000000000000001
</code></pre>
<pre><code class="language-console">$ cargo run -- encode params -v bool true -v u32 42 -v u32 100
0000000000000001000000000000002a0000000000000064
</code></pre>
<p>Note that for every param you want to encode, you must pass a <code>-v</code> flag followed by the type, and then the value: <code>-v &lt;type_1&gt; &lt;value_1&gt; -v &lt;type_2&gt; &lt;value_2&gt; -v &lt;type_n&gt; &lt;value_n&gt;</code></p>
<h3 id="encoding-function-call"><a class="header" href="#encoding-function-call">Encoding function call</a></h3>
<p><code>example/simple.json</code>:</p>
<pre><code class="language-json">[
  {
    &quot;type&quot;:&quot;function&quot;,
    &quot;inputs&quot;:[
      {
        &quot;name&quot;:&quot;arg&quot;,
        &quot;type&quot;:&quot;u32&quot;
      }
    ],
    &quot;name&quot;:&quot;takes_u32_returns_bool&quot;,
    &quot;outputs&quot;:[
      {
        &quot;name&quot;:&quot;&quot;,
        &quot;type&quot;:&quot;bool&quot;
      }
    ]
  }
]
</code></pre>
<pre><code class="language-console">$ cargo run -- encode function examples/simple.json takes_u32_returns_bool -p 4
000000006355e6ee0000000000000004
</code></pre>
<p><code>example/array.json</code></p>
<pre><code class="language-json">[
  {
    &quot;type&quot;:&quot;function&quot;,
    &quot;inputs&quot;:[
      {
        &quot;name&quot;:&quot;arg&quot;,
        &quot;type&quot;:&quot;u16[3]&quot;
      }
    ],
    &quot;name&quot;:&quot;takes_array&quot;,
    &quot;outputs&quot;:[
      {
        &quot;name&quot;:&quot;&quot;,
        &quot;type&quot;:&quot;u16[2]&quot;
      }
    ]
  }
]
</code></pre>
<pre><code class="language-console">$ cargo run -- encode function examples/array.json takes_array -p '[1,2]'
00000000f0b8786400000000000000010000000000000002
</code></pre>
<p>Note that the first word (8 bytes) of the output is reserved for the function selector, which is captured in the last 4 bytes, which is simply the 256hash of the function signature.</p>
<p>Example with nested struct:</p>
<pre><code class="language-json">[
  {
    &quot;type&quot;:&quot;contract&quot;,
    &quot;inputs&quot;:[
      {
        &quot;name&quot;:&quot;MyNestedStruct&quot;,
        &quot;type&quot;:&quot;struct&quot;,
        &quot;components&quot;:[
          {
            &quot;name&quot;:&quot;x&quot;,
            &quot;type&quot;:&quot;u16&quot;
          },
          {
            &quot;name&quot;:&quot;y&quot;,
            &quot;type&quot;:&quot;struct&quot;,
            &quot;components&quot;:[
              {
                &quot;name&quot;:&quot;a&quot;,
                &quot;type&quot;:&quot;bool&quot;
              },
              {
                &quot;name&quot;:&quot;b&quot;,
                &quot;type&quot;:&quot;u8[2]&quot;
              }
            ]
          }
        ]
      }
    ],
    &quot;name&quot;:&quot;takes_nested_struct&quot;,
    &quot;outputs&quot;:[
      
    ]
  }
]
</code></pre>
<pre><code class="language-console">$ cargo run -- encode function examples/nested_struct.json takes_nested_struct -p '(10, (true, [1,2]))'
00000000e8a04d9c000000000000000a000000000000000100000000000000010000000000000002
</code></pre>
<h3 id="decoding-params-only"><a class="header" href="#decoding-params-only">Decoding params only</a></h3>
<p>Similar to encoding parameters only:</p>
<pre><code class="language-console">$ cargo run -- decode params -t bool -t u32 -t u32 0000000000000001000000000000002a0000000000000064
Bool(true)
U32(42)
U32(100)
</code></pre>
<h3 id="decoding-function-output"><a class="header" href="#decoding-function-output">Decoding function output</a></h3>
<pre><code class="language-console">$ cargo run -- decode function examples/simple.json takes_u32_returns_bool 0000000000000001
Bool(true)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
